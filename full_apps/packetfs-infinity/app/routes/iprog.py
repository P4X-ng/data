"""
IPROG ingestion endpoint for client-side PacketFS compression
"""
from __future__ import annotations

import hashlib
import json
from fastapi import APIRouter, Body, HTTPException
from app.core.state import BLUEPRINTS, CURRENT_BLOB

router = APIRouter()


@router.post("/objects/from-iprog")
async def create_object_from_iprog(payload: dict = Body(...)):
    """
    Accept an IPROG generated by client-side PacketFS compression.
    The IPROG contains BREF chunks referencing the shared blob.
    """
    try:
        # Validate IPROG structure
        if not isinstance(payload, dict):
            raise HTTPException(status_code=400, detail="Invalid IPROG format")
        
        # Extract key fields
        sha256 = payload.get("sha256", "")
        size = payload.get("size", 0)
        windows = payload.get("windows", [])
        blob_info = payload.get("blob", {})
        metadata = payload.get("metadata", {})

        # Enforce BREF-only: if any window embeds RAW in PVRT or lacks BREF entirely, reject
        try:
            from packetfs.filesystem.pvrt_container import parse_container, SEC_RAW  # type: ignore
        except Exception:
            parse_container = None  # type: ignore
            SEC_RAW = 0x01  # type: ignore
        
        if not sha256 or not size:
            raise HTTPException(status_code=400, detail="Missing required fields: sha256 or size")
        
        # Verify blob compatibility
        if not CURRENT_BLOB:
            raise HTTPException(status_code=503, detail="Server blob not initialized")
        
        server_blob = CURRENT_BLOB
        client_blob_name = blob_info.get("name", "")
        client_blob_size = blob_info.get("size", 0)
        client_blob_seed = blob_info.get("seed", 0)
        
        # Check if client and server blobs match
        if (server_blob.get("name") != client_blob_name or
            server_blob.get("size") != client_blob_size or
            server_blob.get("seed") != client_blob_seed):
            
            # Log mismatch for debugging
            print(f"Blob mismatch - Server: {server_blob}, Client: {blob_info}")
            # For now, continue anyway as the reconstruction will handle it
        
        # Validate windows are BREF-only
        for w in windows:
            # PVRT present? ensure no RAW section
            pvrt_b64 = w.get("pvrt")
            if pvrt_b64 and parse_container is not None:
                import base64
                try:
                    pvrt_buf = base64.b64decode(str(pvrt_b64))
                    secs = parse_container(pvrt_buf)
                    if SEC_RAW in secs:
                        raise HTTPException(status_code=422, detail="IPROG contains RAW in PVRT; raw fallback is not permitted")
                except HTTPException:
                    raise
                except Exception:
                    raise HTTPException(status_code=400, detail="Invalid PVRT payload in IPROG")
            # BREF list must exist
            bref = w.get("bref") or []
            if not isinstance(bref, list) or len(bref) == 0:
                raise HTTPException(status_code=422, detail="IPROG windows must contain BREF; raw fallback is not permitted")

        # Generate object ID
        obj_id = f"sha256:{sha256}"
        
        # Calculate compressed size from windows
        compressed_size = 0
        for window in windows:
            compressed_size += window.get("compressed_size", 0)
        
        # Calculate compression metrics
        tx_ratio = compressed_size / size if size > 0 else 1.0
        compression_ratio = metadata.get("compression_ratio", 1.0)
        
        # Store the IPROG in blueprints
        BLUEPRINTS[obj_id] = {
            "version": 1,
            "size": size,
            "sha256": sha256,
            "filename": metadata.get("filename", ""),
            "iprog": payload,
            "compressed_size": compressed_size,
            "tx_ratio": tx_ratio,
            "compression_ratio": float(compression_ratio),
            "client_compressed": True,  # Mark as client-compressed
        }
        
        # Return success response
        return {
            "object_id": obj_id,
            "size": size,
            "sha256": sha256,
            "compressed_size": compressed_size,
            "tx_ratio": tx_ratio,
            "compression_ratio": float(compression_ratio),
            "status": "success",
            "message": f"IPROG accepted - {float(compression_ratio):.2f}x compression achieved"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error processing IPROG: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to process IPROG: {str(e)}")