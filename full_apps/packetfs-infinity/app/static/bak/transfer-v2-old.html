<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F3 Transfer - Lightning Fast File Sharing</title>
    <link href="https://releases.transloadit.com/uppy/v5.1.1/uppy.min.css" rel="stylesheet" />
    <link rel="icon" href="/static/f3_logo.png" type="image/png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        /* Fail Overlay */
        .fail-overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 9999; background: rgba(0,0,0,0.85); backdrop-filter: blur(4px); }
        .fail-card { text-align: center; padding: 2rem 2.5rem; border: 1px solid #3a0000; border-radius: 12px; background: rgba(58,0,0,0.4); box-shadow: 0 10px 32px rgba(0,0,0,0.5); }
        .fail-title { font-size: 2.25rem; color: #ff5252; font-weight: 800; letter-spacing: 0.5px; margin-bottom: 0.5rem; text-shadow: 0 0 18px rgba(255,82,82,0.35); }
        .fail-sub { color: #ffb3b3; margin-bottom: 1rem; }
        .fail-metrics { color: #ddd; margin-top: 0.75rem; font-size: 0.95rem; opacity: 0.9; }
        .fail-actions { margin-top: 1.25rem; display: flex; gap: 0.75rem; justify-content: center; }
        .fail-btn { padding: 0.6rem 1rem; border: 1px solid #444; background: rgba(255,255,255,0.08); color: #eee; border-radius: 8px; cursor: pointer; }
        .fail-btn:hover { background: rgba(255,255,255,0.14); }
        .fail-count { color: #ffb3b3; font-weight: 600; }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header */
        .header {
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #16213e;
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            height: 72px;
            width: auto;
            filter: drop-shadow(0 4px 8px rgba(79, 195, 247, 0.3));
            background: transparent;
            mix-blend-mode: screen;
        }

        .brand-text h1 {
            font-size: 1.75rem;
            font-weight: 700;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.25rem;
        }

        .brand-text p {
            font-size: 0.875rem;
            color: #999;
            margin-bottom: 0.25rem;
        }
        
        .brand-tagline {
            font-size: 0.75rem;
            color: #4fc3f7;
            font-style: italic;
            opacity: 0.9;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 30px;
            overflow: hidden;
            border: 1px solid #333;
        }

        .mode-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #999;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
        }

        /* Main Content */
        .transfer-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .transfer-section {
            background: rgba(26, 26, 46, 0.6);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid #333;
            transition: all 0.3s;
        }

        .transfer-section:hover {
            border-color: #4fc3f7;
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.1);
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-icon {
            font-size: 1.5rem;
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed #4fc3f7;
            border-radius: 8px;
            padding: 3rem;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: rgba(79, 195, 247, 0.05);
        }

        .upload-zone:hover {
            background: rgba(79, 195, 247, 0.1);
            border-color: #29b6f6;
        }

        .upload-zone.dragover {
            background: rgba(79, 195, 247, 0.2);
            border-color: #29b6f6;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .upload-text {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .upload-subtext {
            font-size: 0.875rem;
            color: #999;
        }

        #fileInput {
            display: none;
        }

        /* Download Section */
        .download-input-group {
            margin-bottom: 1.5rem;
        }

        .input-label {
            display: block;
            font-size: 0.875rem;
            color: #999;
            margin-bottom: 0.5rem;
        }

        .input-wrapper {
            position: relative;
        }

        .input-field {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .input-field:focus {
            outline: none;
            border-color: #4fc3f7;
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.1);
        }

        /* File List */
        .file-list {
            max-height: 70vh; /* expand vertical space */
            overflow-y: auto;
            margin-bottom: 1.2rem;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.35rem 0.5rem; /* tighter */
            background: rgba(0, 0, 0, 0.18);
            border-radius: 4px;
            margin-bottom: 0.25rem;
            transition: background 0.2s;
            font-size: 0.8rem;
            line-height: 1.1rem;
        }

        .file-item:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .file-icon {
            font-size: 0.8rem; /* smaller icon */
            opacity: 0.85;
            width: 0.9rem;
            text-align: center;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            margin-bottom: 0.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            font-size: 0.75rem;
            color: #999;
        }

        .file-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
        }

        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.4);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid #333;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-danger {
            background: #f44336;
            color: white;
            padding: 0.5rem;
            font-size: 0.875rem;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-container {
            margin: 1rem 0;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #29b6f6);
            border-radius: 4px;
            transition: width 0.3s;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: rgba(26, 26, 46, 0.6);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #333;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #4fc3f7;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #999;
        }

        /* Activity Log */
        .activity-log {
            background: rgba(26, 26, 46, 0.6);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #333;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .log-content {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            display: flex;
            gap: 1rem;
        }

        .log-time {
            color: #666;
        }

        .log-message {
            flex: 1;
        }

        .log-success { color: #4caf50; }
        .log-error { color: #f44336; }
        .log-info { color: #4fc3f7; }

        /* Responsive */
        @media (max-width: 768px) {
            .transfer-container {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Settings Panel */
        .settings-panel {
            background: rgba(26, 26, 46, 0.6);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #333;
            margin-bottom: 2rem;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            animation: slideIn 0.3s ease;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-success { border-color: #4caf50; }
        .toast-error { border-color: #f44336; }
        .toast-info { border-color: #4fc3f7; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Big FAIL overlay -->
        <div id="failOverlay" class="fail-overlay" role="dialog" aria-modal="true" aria-labelledby="failTitle">
            <div class="fail-card">
                <div id="failTitle" class="fail-title">TRANSFER FAILED</div>
                <div id="failSub" class="fail-sub">Weâ€™ll retry automatically in <span id="failCountdown" class="fail-count">3</span>sâ€¦</div>
                <div id="failMetrics" class="fail-metrics">â€”</div>
                <div class="fail-actions">
                    <button id="failRetryNow" class="fail-btn">Retry now</button>
                    <button id="failDismiss" class="fail-btn">Dismiss</button>
                </div>
            </div>
        </div>
        <!-- Auth / Session Bar -->
        <div id="authBar" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;gap:1rem;flex-wrap:wrap;">
          <div id="authStatus" style="font-size:0.7rem;opacity:0.8;">Checking sessionâ€¦</div>
          <div id="authActions" style="display:flex;gap:0.4rem;flex-wrap:wrap;"></div>
          <div id="authMode" style="font-size:0.6rem;opacity:0.55;">auth: ?</div>
        </div>

        <!-- Header -->
        <div class="header">
            <div class="brand">
                <img src="/static/f3_logo.png" alt="F3" class="logo">
                <div class="brand-text">
                    <h1>F3 Transfer</h1>
                    <p>Lightning fast file transfer with 99%+ compression</p>
                    <span class="brand-tagline" id="brandTagline">Powered by BLACK MAGIC</span>
                </div>
            </div>
        </div>
        <!-- Progressive Blob Prep Banner -->
        <div id="blobPrep" style="display:none;margin:0 0 1rem 0;padding:0.9rem 1rem;background:#142033;border:1px solid #203247;border-radius:8px;">
            <div style="display:flex;align-items:center;gap:0.6rem;flex-wrap:wrap;">
                <strong style="font-size:0.85rem;letter-spacing:0.5px;">Preparing Hypercannons</strong>
                <span id="blobPrepPct" style="font-size:0.7rem;opacity:0.75;">0%</span>
                <span id="blobPrepLabel" style="font-size:0.7rem;opacity:0.8;">Initializingâ€¦</span>
                <button id="blobPrepStartBtn" style="display:none;font-size:0.6rem;padding:0.35rem 0.6rem;background:#21507a;border:1px solid #2e6d9f;border-radius:4px;cursor:pointer;">Start</button>
            </div>
            <div style="margin-top:0.55rem;background:#1d2b40;border:1px solid #26405a;height:14px;border-radius:7px;position:relative;overflow:hidden;">
                <div id="blobPrepFill" style="background:linear-gradient(90deg,#2d8bff,#6fddff);height:100%;width:0%;transition:width 0.35s ease;"></div>
            </div>
            <div id="blobPrepEta" style="margin-top:0.4rem;font-size:0.6rem;opacity:0.65;display:none;">ETA: --s</div>
        </div>

        <!-- Stats -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="transferSpeed">0 MB/s</div>
                <div class="stat-label">Transfer Speed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="compressionRatio">0%</div>
                <div class="stat-label">Compression</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalTransferred">0 GB</div>
                <div class="stat-label">Total Transferred</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="activeTransfers">0</div>
                <div class="stat-label">Active Transfers</div>
            </div>
        </div>
        <div id="tenantCompressionBanner" style="display:none;margin:-0.5rem 0 1.5rem 0;padding:0.75rem 1rem;border:1px solid #1d3d52;background:rgba(30,60,90,0.4);border-radius:8px;font-size:0.75rem;line-height:1.15rem;">
            <strong style="color:#4fc3f7;">Tenant Compression</strong>
            <span id="tenantCompressionStats" style="margin-left:0.75rem;opacity:0.85;">--</span>
            <span id="tenantIdLabel" style="float:right;opacity:0.55;">tenant: public</span>
        </div>

        <!-- My Files Section -->
        <div class="transfer-container" style="margin-bottom: 2rem;">
            <div class="transfer-section" style="grid-column: 1 / -1;">
                <h2 class="section-title">My Files</h2>
                <div class="file-list" id="myFilesList" style="max-height: min(70vh, 800px); overflow-y: auto;">
                    <div style="text-align: center; color: #666; padding: 1rem;">
                        Loading files...
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="refreshFiles()" style="width: 100%; margin-top: 1rem;">
                    Refresh Files
                </button>
            </div>
        </div>

        <!-- Transfer Sections -->
        <div class="transfer-container">
            <!-- Upload Section -->
            <div class="transfer-section">
                <h2 class="section-title">Upload Files</h2>
                
                <!-- Uppy Dashboard -->
                <div id="uppy-dashboard" style="min-height: 400px;"></div>

                <!-- Explicit pickers -->
                <div style="display:flex; gap:0.5rem; margin-top:0.5rem; align-items:center;">
                    <button class="btn btn-secondary" type="button" onclick="openFilePicker()">Select files</button>
                    <button class="btn btn-secondary" type="button" onclick="openFolderPicker()">Select folder</button>
                    <label style="display:flex; align-items:center; gap:0.4rem; font-size:0.85rem; color:#ccc;">
                        <input id="packFolderTar" type="checkbox" checked> Pack folder into .tar (stream via OPFS)
                    </label>
                    <input id="filePicker" type="file" multiple style="display:none;" />
                    <input id="folderPicker" type="file" webkitdirectory directory multiple style="display:none;" />
                </div>

<div class="progress-container" id="uploadProgress" style="display: none;">
                    <div class="progress-header">
                        <span id="uploadFileName">Uploading...</span>
                        <span id="uploadPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="uploadProgressFill" style="width: 0%"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.875rem; color: #999;">
                        <span id="uploadSpeed">0 MB/s</span>
                        <span id="uploadETA">ETA: --</span>
                    </div>
                </div>
                <!-- Overall progress across all files (Uppy or legacy) -->
                <div class="progress-container" id="overallProgress" style="display: none;">
                    <div class="progress-header">
                        <span>Overall Upload</span>
                        <span id="overallPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="overallProgressFill" style="width: 0%"></div>
                    </div>
                </div>

                <button class="btn btn-primary" onclick="startUpload()" id="uploadBtn" disabled style="width: 100%; margin-top: 1rem;">
                    Start Upload
                </button>
            </div>

            <!-- Storage Info Section -->
            <div class="transfer-section">
                <h2 class="section-title">Your Storage</h2>
                
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-size: 3rem; font-weight: 700; color: #4fc3f7; margin-bottom: 1rem;">âˆž</div>
                    <div style="font-size: 1.25rem; color: #e0e0e0; margin-bottom: 0.5rem;">Unlimited Storage</div>
                    <div style="font-size: 0.875rem; color: #999;">Powered by MATH</div>
                </div>
                
<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-top: 2rem;">
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; color: #4fc3f7; font-weight: 600;" id="totalFiles">0</div>
                        <div style="font-size: 0.875rem; color: #999;">Files Stored</div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; color: #4fc3f7; font-weight: 600;" id="spaceSaved">0 B</div>
                        <div style="font-size: 0.875rem; color: #999;">Space Saved</div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; color: #4fc3f7; font-weight: 600;" id="storageUsed">0 B</div>
                        <div style="font-size: 0.875rem; color: #999;">Storage Used</div>
                    </div>
                </div>
                
                <div style="margin-top: 2rem; padding: 1rem; background: rgba(79, 195, 247, 0.1); border-radius: 8px; border: 1px solid #4fc3f7;">
                    <div style="font-size: 0.875rem; color: #4fc3f7; margin-bottom: 0.5rem;">âœ¨ How it works:</div>
                    <div style="font-size: 0.75rem; color: #999; line-height: 1.5;">
                        Your files disappear into pure mathematics. 
                        99%+ compression through arcane arithmetic rituals. 
                        Infinite storage because equations weigh nothing.
                    </div>
                </div>
            </div>
        </div>


        <!-- Acceleration/Blob Bootstrap Banner -->
        <div class="settings-panel" style="margin-top: 1rem;">
            <h3 style="margin-bottom: 0.5rem;">Priming cache</h3>
            <div class="transfer-section" style="padding: 1rem; display:grid; gap: 0.75rem;">
                <div style="font-size: 0.875rem; color: #999;">
                    One-time setup to enable blueprint transfers. This will prepare a local dictionary (blob) so future downloads transfer tiny blueprints instead of payloads.
                </div>
                <div style="display:flex; gap:1rem; align-items:center;">
                    <label style="display:flex; align-items:center; gap:0.5rem; font-size:0.875rem; color:#ccc;">
                        <input type="checkbox" id="saveBlobFlag" checked>
                        Save for next time (uses your browser's private storage)
                    </label>
                    <button class="btn btn-primary" onclick="primeCache()" id="primeBtn">Start priming</button>
                    <button class="btn btn-secondary" onclick="primeClear()" id="primeClearBtn" disabled>Delete cache</button>
                    <span id="primeHint" style="font-size:0.8rem; color:#666;"></span>
                </div>
                <div style="height:10px; background:#222; border:1px solid #333; border-radius:6px; overflow:hidden;">
                    <div id="primeBar" style="height:100%; width:0%; background:linear-gradient(90deg, #29b6f6, #4fc3f7);"></div>
                </div>
                <div id="primeStatus" style="font-size:0.8rem; color:#999;">Idle</div>
            </div>
        </div>

        <!-- Activity Log -->
        <div class="activity-log">
            <div class="log-header">
                <h3>Activity Log</h3>
                <button class="btn btn-secondary" onclick="clearLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Clear</button>
            </div>
            <div class="log-content" id="activityLog"></div>
        </div>

        <!-- Terminal Panel (hidden) -->
        <div id="terminalPanel" class="settings-panel" style="margin-top: 2rem; display:none;">
            <h3 style="margin-bottom: 1rem;">Terminal</h3>
            <div class="transfer-section" style="padding: 1rem; display:grid; gap: 0.75rem;">
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr auto auto; gap: 0.5rem; align-items:center;">
                    <input class="input-field" id="termHost" placeholder="host (default localhost)">
                    <input class="input-field" id="termUser" placeholder="user (default punk)">
                    <input class="input-field" id="termPass" placeholder="password (optional)" type="password">
                    <button class="btn btn-secondary" onclick="termConnect()">Connect</button>
                    <button class="btn btn-secondary" onclick="termDisconnect()">Disconnect</button>
                </div>
                <pre id="termOutput" style="height:200px; overflow:auto; background: rgba(0,0,0,0.3); border:1px solid #333; border-radius:6px; padding:0.5rem; font-family:'Courier New', monospace; font-size:0.9rem;"></pre>
                <div style="display:grid; grid-template-columns: 1fr auto; gap: 0.5rem;">
                    <input class="input-field" id="termInput" placeholder="Enter command" onkeydown="if(event.key==='Enter'){termSend()}">
                    <button class="btn btn-primary" onclick="termSend()">Send</button>
                </div>
            </div>
        </div>

        <!-- Commands Panel (hidden) -->
        <div id="commandsPanel" class="settings-panel" style="margin-top: 1rem; display:none;">
            <h3 style="margin-bottom: 1rem;">Suggested Commands</h3>
            <div class="transfer-section" style="padding: 1rem;">
                <div class="file-list" id="commandsList" style="max-height: 200px;"></div>
            </div>
        </div>

    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
// ---- Auth & Session Handling ----
async function fetchAuthMode(){
  try{
    const r = await fetch('/auth/whoami'); // piggyback; middleware not needed
    const enabled = (window.__AUTH_ENABLED__ !== undefined) ? window.__AUTH_ENABLED__ : undefined; // placeholder
  }catch{}
}
async function toggleAuth(enable){
  const token = localStorage.getItem('pfs_admin_token')||'';
  try {
    const r = await fetch('/auth/'+(enable?'enable':'disable'), {method:'POST', headers: token?{'X-Admin-Token':token}:{}});
    const j = await r.json();
    if (r.ok){ showToast('Auth '+(enable?'enabled':'disabled'),'info'); updateAuthMode(j.auth_enabled); } else { showToast('Auth toggle failed','error'); }
  } catch { showToast('Auth toggle error','error'); }
}
function updateAuthMode(enabled){
  const el=document.getElementById('authMode'); if(el) el.textContent = 'auth: '+(enabled?'on':'off');
}
async function fetchProviders() {
  try {
    const r = await fetch('/auth/providers');
    if (!r.ok) return [];
    return await r.json();
  } catch { return []; }
}
async function fetchWhoAmI() {
  try {
    const r = await fetch('/auth/whoami');
    if (!r.ok) return null;
    return await r.json();
  } catch { return null; }
}
let speedEMA = null; // for smoothing
const SPEED_ALPHA = 0.25; // smoothing factor
function smoothSpeed(raw){
  if(raw<=0 || !isFinite(raw)) return 0;
  if(speedEMA==null) speedEMA = raw; else speedEMA = SPEED_ALPHA*raw + (1-SPEED_ALPHA)*speedEMA;
  return speedEMA;
}

// ---- Priming UX helpers (debounce + single-flight) ----
window.__primeBusy = window.__primeBusy || false;
window.__primeWS = window.__primeWS || null;
window.__setPrimeStatus = window.__setPrimeStatus || null;
function makeStatusSetter(el){
  let last = '';
  let lastTs = 0;
  return function setStatus(text, opts){
    opts = opts || {};
    const now = (window.performance && performance.now) ? performance.now() : Date.now();
    const important = /error|failed|complete/i.test(text) || opts.force === true;
    if (text === last) return;
    if (!important && (now - lastTs) < 250) return; // debounce
    el.textContent = text;
    last = text;
    lastTs = now;
  };
}
function renderAuth(providers, user){
  const statusEl = document.getElementById('authStatus');
  const actEl = document.getElementById('authActions');
  actEl.innerHTML='';
  if (user && user.user_id) {
    statusEl.textContent = `Signed in as ${user.user_id}`;
    const btn = document.createElement('button');
    btn.className='btn btn-secondary';
    btn.textContent='Logout';
    btn.onclick=async()=>{ await fetch('/auth/logout',{method:'POST'}); speedEMA=null; initAuth(); };
    actEl.appendChild(btn);
  } else {
    statusEl.textContent = 'Not signed in';
    (providers.providers||providers||[]).forEach(p=>{
      const id = p.id || p.name;
      const btn=document.createElement('button');
      btn.className='btn btn-secondary';
      btn.textContent=p.display || id;
      btn.onclick=()=>{ if(p.kind==='joke'){ runJoke(id); } else { window.location.href=`/auth/login?provider=${encodeURIComponent(id)}`; } };
      actEl.appendChild(btn);
    });
  }
}
async function runJoke(id){
  try { const r=await fetch(`/auth/login?provider=${encodeURIComponent(id)}`); const j=await r.json(); showToast(j.message||'ðŸ‘»', 'info'); } catch { showToast('TikTok auth failed (lol)','info'); }
}
async function initAuth(){
  const [prov, who, status] = await Promise.all([
    fetchProviders(),
    fetchWhoAmI(),
    fetch('/auth/status').then(r=>r.json()).catch(()=>({}))
  ]);
  renderAuth(prov.providers||prov, who);
  if(status && 'auth_enabled' in status){ updateAuthMode(status.auth_enabled); }
  if (who && who.tenant_id) {
    const tId = document.getElementById('tenantIdLabel');
    if (tId) tId.textContent = 'tenant: '+who.tenant_id;
  }
}
window.addEventListener('DOMContentLoaded', ()=>{ initAuth(); });
// ---- End Auth ----

        // --------- Blob Bootstrap (Priming cache) ---------
        function canonicalBlobFileName(meta) {
            const name = meta.name || 'pfs_vblob';
            const size = meta.size || 0;
            const ws = meta.window_size || 65536;
            return `${name}_${size}_${ws}.blob`;
        }

        async function getOPFSRoot() {
            if (!navigator.storage || !navigator.storage.getDirectory) return null;
            try { return await navigator.storage.getDirectory(); } catch { return null; }
        }

        async function existsOPFSFile(root, name) {
            try {
                const fh = await root.getFileHandle(name, {create:false});
                const f = await fh.getFile();
                return { exists: true, size: f.size };
            } catch { return { exists: false, size: 0 }; }
        }

        async function primeClear() {
            const btn = document.getElementById('primeClearBtn');
            const st = document.getElementById('primeStatus');
            btn.disabled = true;
            try {
                const res = await fetch('/blob/status');
                const j = await res.json();
                if (!j || j.status !== 'attached') throw new Error('no blob');
                const root = await getOPFSRoot();
                if (!root) throw new Error('no OPFS');
                const meta = { name: j.name, size: j.size, window_size: 65536 };
                const fname = canonicalBlobFileName(meta);
                await root.removeEntry(fname);
                localStorage.removeItem('pfs_blob_info');
                document.getElementById('primeBar').style.width = '0%';
                st.textContent = 'Cache cleared. You can prime cache again (one-time).';
                document.getElementById('primeBtn').disabled = false;
            } catch (e) {
                st.textContent = 'Delete failed: ' + (e.message||e);
            } finally {
                btn.disabled = false;
            }
        }

        async function checkPrimed() {
            const bar = document.getElementById('primeBar');
            const st = document.getElementById('primeStatus');
            const primeBtn = document.getElementById('primeBtn');
            const clearBtn = document.getElementById('primeClearBtn');
            try {
                const res = await fetch('/blob/status');
                const j = await res.json();
                if (!j || j.status !== 'attached') return;
                const root = await getOPFSRoot();
                if (!root) return;
                const meta = { name: j.name, size: j.size, window_size: 65536 };
                const fname = canonicalBlobFileName(meta);
                const ex = await existsOPFSFile(root, fname);
                // Read any previous local record
                let info = null;
                try { info = JSON.parse(localStorage.getItem('pfs_blob_info') || 'null'); } catch {}
                if (ex.exists && ex.size === (j.size|0)) {
                    if (info && info.id && info.id === j.id) {
                        // Strict match: id matches server
                        localStorage.setItem('pfs_blob_info', JSON.stringify({ id: j.id, name: j.name, size: j.size, window_size: 65536, file: fname }));
                        bar.style.width = '100%';
                        st.textContent = 'Acceleration enabled â€” cache present (one-time)';
                        primeBtn.disabled = true;
                        primeBtn.textContent = 'Start priming';
                        clearBtn.disabled = false;
                    } else {
                        // Mismatch: prompt re-prime
                        bar.style.width = '0%';
                        const oldId = info && info.id ? info.id : 'unknown';
                        st.textContent = `Server dictionary changed (have id=${oldId}, need id=${j.id}). Re-prime required.`;
                        primeBtn.disabled = false;
                        primeBtn.textContent = 'Re-prime';
                        clearBtn.disabled = false;
                    }
                }
            } catch { /* ignore */ }
        }

async function primeCache() {
            const btn = document.getElementById('primeBtn');
            const bar = document.getElementById('primeBar');
            const st = document.getElementById('primeStatus');
            const setStatus = (window.__setPrimeStatus ||= makeStatusSetter(st));
            const saveForNext = !!(document.getElementById('saveBlobFlag')||{}).checked;
            if (window.__primeBusy) { return; }
            window.__primeBusy = true;
            btn.disabled = true; setStatus('Checking storage...', {force:true});

            // Ensure server blob is attached before attempting WS to avoid rapid fail/retry
            let serverBlob = null;
            try {
                const res = await fetch('/blob/status');
                serverBlob = await res.json();
                if (!(serverBlob && serverBlob.attached === true)) {
                    st.textContent = 'Server not ready (dictionary not attached). Try again shortly.';
                    btn.disabled = false;
                    window.__primeBusy = false;
                    return;
                }
            } catch (e) {
                st.textContent = 'Priming error: ' + (e.message||e);
                btn.disabled = false;
                window.__primeBusy = false;
                return;
            }

            let writable = null;
            let writer = null;
            let useOPFS = false;
            try {
                if (saveForNext && navigator.storage && navigator.storage.persist) {
                    await navigator.storage.persist();
                }
                if (saveForNext && navigator.storage && navigator.storage.getDirectory) {
                    // OPFS
                    const root = await navigator.storage.getDirectory();
                    // Temp name until manifest arrives
                    const fh = await root.getFileHandle('pfs_vblob.tmp', {create:true});
                    writable = await fh.createWritable();
                    useOPFS = true;
                }
            } catch (e) {
                useOPFS = false;
            }

const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
const wsc = new WebSocket(`${protocol}//${window.location.host}/ws/blob-bootstrap`);
            window.__primeWS = wsc;
            wsc.binaryType = 'arraybuffer';
            let size = (serverBlob && serverBlob.size) || 0, windowSize = 65536, total = Math.ceil(size / windowSize), received = 0;
            let currentWin = -1; let currentBuf = new Uint8Array(0);
            let fileHandle = null; let opfsStream = writable;
            let fileName = 'pfs_vblob.bin';

            function setProgress(done, tot) {
                const pct = tot > 0 ? Math.floor((done / tot) * 100) : 0;
                bar.style.width = `${pct}%`;
                setStatus(`Priming cache: ${done}/${tot} windows (${pct}%) â€” one-time setup`);
            }

            // Prefer HTTP streaming for priming
            try {
                const meta = { name: (serverBlob && serverBlob.name) || 'pfs_vblob', size: (serverBlob && serverBlob.size) || 0, window_size: 65536 };
                const fname = canonicalBlobFileName(meta);
                if (useOPFS && opfsStream) {
                    // Stream over HTTPS
                    const resp = await fetch('/blob/raw');
                    if (!resp.ok || !resp.body) throw new Error('HTTP prime failed');
                    // If we created a temp handle earlier, recreate with canonical name
                    try {
                        const root = await navigator.storage.getDirectory();
                        try { await root.removeEntry(fname); } catch {}
                        const fh2 = await root.getFileHandle(fname, {create:true});
                        await opfsStream.close();
                        opfsStream = await fh2.createWritable();
                        fileName = fname;
                    } catch {}
                    const reader = resp.body.getReader();
                    let receivedBytes = 0;
                    const totalBytes = parseInt(resp.headers.get('Content-Length')||'0',10) || meta.size;
                    const totalWins = Math.ceil(totalBytes / meta.window_size);
                    while (true) {
                        const {done, value} = await reader.read();
                        if (done) break;
                        if (value && value.length) {
                            await opfsStream.write(new Blob([value]));
                            receivedBytes += value.length;
                            const doneWins = Math.floor(receivedBytes / meta.window_size);
                            setProgress(doneWins, totalWins);
                        }
                    }
                    await opfsStream.close();
                    setStatus('Priming complete â€” acceleration enabled (one-time)', {force:true});
                    try {
                        const idToStore = (serverBlob && serverBlob.id) || '';
                        localStorage.setItem('pfs_blob_info', JSON.stringify({ id: idToStore, name: meta.name, size: meta.size, window_size: meta.window_size, file: fname }));
                        document.getElementById('primeClearBtn').disabled = false;
                        document.getElementById('primeBar').style.width = '100%';
                    } catch {}
                    btn.disabled = false; window.__primeBusy = false; window.__primeWS = null;
                    return;
                }
            } catch (e) {
                // fall back to WS path below
            }

            function parseFramesConcat(ab) {
                const u8 = ab instanceof Uint8Array ? ab : new Uint8Array(ab);
                const frames = [];
                let off = 0;
                while (off + 2 + 8 + 4 + 1 <= u8.length) {
                    if (u8[off] !== 0x50 || u8[off+1] !== 0x46) break; // 'P''F'
                    off += 2;
                    const dv = new DataView(u8.buffer, u8.byteOffset + off, 13);
                    const seq = Number(dv.getBigUint64(0));
                    const ln = dv.getUint32(8);
                    const flags = dv.getUint8(12);
                    off += 13;
                    if (off + ln > u8.length) break;
                    const payload = u8.slice(off, off + ln);
                    off += ln;
                    frames.push({seq, flags, payload});
                }
                return frames;
            }

            function pvrtExtractRaw(u8) {
                if (u8.length < 5) return null;
                if (u8[0] !== 0x50 || u8[1] !== 0x4F || u8[2] !== 0x58 || u8[3] !== 0x31) return null; // 'P''O''X''1'
                let off = 4;
                const nsec = u8[off]; off += 1;
                for (let i = 0; i < nsec; i++) {
                    if (off + 5 > u8.length) break;
                    const tp = u8[off];
                    const dv = new DataView(u8.buffer, u8.byteOffset + off + 1, 4);
                    const ln = dv.getUint32(0);
                    off += 5;
                    if (off + ln > u8.length) break;
                    const data = u8.slice(off, off + ln);
                    off += ln;
                    if (tp === 0x01) return data; // SEC_RAW
                }
                return null;
            }

wsc.onopen = () => { setStatus('Negotiatingâ€¦', {force:true}); };
            let mfstId = '';
            wsc.onmessage = async (ev) => {
                try {
                    if (typeof ev.data === 'string') {
                        // JSON control or final ack
                        try {
                            const j = JSON.parse(ev.data);
                            const t = j.type || '';
                            if (t === 'MFST') {
                                size = j.size || 0; windowSize = j.window_size || 65536; total = j.total_windows || 0;
                                mfstId = String(j.id || '');
                                if (useOPFS && writable && j.blob) {
                                    // Rename file logically by recreating handle with canonical name
                                    try {
                                        const root = await navigator.storage.getDirectory();
                                        fileName = `${j.blob}_${size}_${windowSize}.blob`;
                                        try { await root.removeEntry(fileName); } catch {}
                                        const fh2 = await root.getFileHandle(fileName, {create:true});
                                        await writable.close();
                                        opfsStream = await fh2.createWritable();
                                    } catch { /* ignore */ }
                                }
                                setProgress(0, total);
                            } else if (t === 'WIN') {
                                currentWin = j.idx|0; currentBuf = new Uint8Array(0);
                            } else if (t === 'END') {
                                // Decode PVRT; write RAW to storage
                                const raw = pvrtExtractRaw(currentBuf);
                                if (raw && raw.length) {
                                    const start = currentWin * windowSize;
                                    if (useOPFS && opfsStream) {
                                        await opfsStream.seek(start);
                                        await opfsStream.write(new Blob([raw]));
                                    }
                                }
                                received += 1; setProgress(received, total);
                            } else if (t === 'DONE') {
                                // finalize
                            }
                        } catch (e) {
                            // maybe 'done'/'error'
                            if (typeof ev.data === 'string' && ev.data.startsWith('error')) {
setStatus('Priming error: ' + ev.data, {force:true});
                                try { wsc.close(); } catch {}
                                btn.disabled = false;
                                window.__primeBusy = false;
                                return;
                            }
if (typeof ev.data === 'string' && ev.data.startsWith('done')) {
                                if (useOPFS && opfsStream) { await opfsStream.close(); }
                            setStatus('Priming complete â€” acceleration enabled (one-time)', {force:true});
                                try {
                                    const meta = { name: (fileName.split('_')[0]||'pfs_vblob'), size: size, window_size: windowSize };
                                    const idToStore = mfstId || '';
                                    localStorage.setItem('pfs_blob_info', JSON.stringify({ id: idToStore, name: meta.name, size: size, window_size: windowSize, file: fileName }));
                                    document.getElementById('primeClearBtn').disabled = false;
                                    document.getElementById('primeBar').style.width = '100%';
                                } catch {}
btn.disabled = false;
                                window.__primeBusy = false;
                                window.__primeWS = null;
                            }
                        }
                    } else if (ev.data instanceof ArrayBuffer) {
                        const frames = parseFramesConcat(ev.data);
                        for (const fr of frames) {
                            if (fr.flags === 0) { // DATA
                                // append payload
                                const newBuf = new Uint8Array(currentBuf.length + fr.payload.length);
                                newBuf.set(currentBuf, 0); newBuf.set(fr.payload, currentBuf.length);
                                currentBuf = newBuf;
                            }
                        }
                    }
                } catch (e) {
setStatus('Priming error: ' + (e.message||e), {force:true});
                    try { wsc.close(); } catch {}
                    btn.disabled = false;
                    window.__primeBusy = false;
                }
            };
            let retries = 0;
            const maxRetries = 2;
wsc.onerror = () => { if (received === 0) setStatus('Priming error (network)'); };
            wsc.onclose = async () => {
                if (retries < maxRetries) {
                    retries++;
setStatus(`Priming: retrying (${retries}/${maxRetries})...`);
                    await new Promise(r => setTimeout(r, 600));
                    // allow re-entry for retry
                    window.__primeBusy = false;
                    try { if (window.__primeWS === wsc) { await primeCache(); } } catch {}
                } else {
setStatus('Priming failed. Ensure server blob is attached.', {force:true});
                    const hint = document.getElementById('primeHint');
                    if (hint) hint.textContent = 'Tip: server can auto-attach; otherwise POST /blob/setup';
                    btn.disabled = false;
                    window.__primeBusy = false;
                }
            };
        }

            // Initialize WebSocket connection
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const res = await fetch('/blob/status');
                const js = await res.json();
                if (!(js && js.attached === true)) {
                    // Server not ready yet; show idle and do not auto-prime to avoid rapid retry/fail loop
                    const st = document.getElementById('primeStatus');
                    if (st) st.textContent = 'Idle';
                    return;
                }
            } catch {}
            // Auto-attempt dictionary priming silently; if already primed this is cheap.
            checkPrimed().then(() => {
                const st = document.getElementById('primeStatus');
                if (st && /re-prime required/i.test(st.textContent)) {
                    // Auto re-prime if mismatch so user doesn't have to click.
                    try { primeCache(); } catch {}
                } else if (st && /Idle/.test(st.textContent)) {
                    // If idle (never primed) attempt an automatic prime
                    try { primeCache(); } catch {}
                }
            });
        });

        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws/transfer`);

            ws.onopen = () => {
                log('Connected to transfer service', 'success');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleTransferUpdate(data);
                } catch (e) {
                    // ignore malformed events
                }
            };

            ws.onerror = (error) => {
                log('WebSocket error: ' + error, 'error');
            };

            ws.onclose = () => {
                log('Disconnected from transfer service', 'info');
                setTimeout(initWebSocket, 3000); // Reconnect
            };
        }

        // Handle file selection
        function handleFileSelect(event) {
            const files = event.target.files;
            for (let file of files) {
                addFileToUploadQueue(file);
            }
        }

        // Drag and drop
        const uploadZone = document.getElementById('uploadZone');
        if (uploadZone) {
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                for (let file of files) {
                    addFileToUploadQueue(file);
                }
            });
        }

        // Add file to upload queue
        function addFileToUploadQueue(file) {
            const fileId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            uploadQueue.push({
                id: fileId,
                file: file,
                status: 'pending'
            });

            // Add to UI
            const uploadList = document.getElementById('uploadList');
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.id = `upload_${fileId}`;
            fileItem.innerHTML = `
                <div class="file-info">
                    <span class="file-icon">ðŸ“„</span>
                    <div class="file-details">
                        <div class="file-name">${file.name}</div>
                        <div class="file-meta">${formatFileSize(file.size)} â€¢ ${file.type || 'Unknown type'}</div>
                    </div>
                </div>
                <div class="file-actions">
                    <button class="btn btn-danger" onclick="removeFromUpload('${fileId}')">âœ•</button>
                </div>
            `;
            uploadList.appendChild(fileItem);

            document.getElementById('uploadBtn').disabled = false;
            log(`Added ${file.name} to upload queue`, 'info');
        }

        // Remove from upload
        function removeFromUpload(fileId) {
            uploadQueue = uploadQueue.filter(f => f.id !== fileId);
            document.getElementById(`upload_${fileId}`).remove();
            
            if (uploadQueue.length === 0) {
                document.getElementById('uploadBtn').disabled = true;
            }
        }

        // Start upload
        async function startUpload() {
            // Prefer Uppy if initialized
            if (window.uppy) {
                try {
                    await window.uppy.upload();
                } catch (e) {
                    showToast('Upload failed', 'error');
                }
                return;
            }

            // Legacy fallback
            if (uploadQueue.length === 0) return;
            const uploadBtn = document.getElementById('uploadBtn');
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';

            for (let item of uploadQueue) {
                if (item.status === 'pending') {
                    await uploadFile(item);
                }
            }

            uploadBtn.textContent = 'Start Upload';
            uploadBtn.disabled = uploadQueue.length === 0;
        }

        // Upload single file
        async function uploadFile(item, attempt=1) {
            const formData = new FormData();
            formData.append('file', item.file);
            
            // Show progress
            document.getElementById('uploadProgress').style.display = 'block';
            document.getElementById('uploadFileName').textContent = item.file.name + (attempt>1?` (retry ${attempt-1})`:'');
            
            const startTime = Date.now();
            
            // Return a promise that resolves/rejects when the XHR finishes
            return await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                let done = false;

                // Track upload progress
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        updateUploadProgress(percentComplete, e.loaded, e.total, startTime);
                    }
                });

                xhr.addEventListener('load', () => {
                    try {
                        const ok = xhr.status >= 200 && xhr.status < 300;
                        if (!ok) throw new Error(`HTTP ${xhr.status}`);
                        let response = {};
                        try {
                            response = xhr.responseType === 'json' && xhr.response ? xhr.response : JSON.parse(xhr.responseText || '{}');
                        } catch (_) {
                            response = {};
                        }
                        item.status = 'completed';

                        // Calculate compression savings and factor
                        const orig = item.file.size;
                        let compressedSize = orig;
                        if (response && typeof response === 'object') {
                            if (response.compressed_size != null) compressedSize = Number(response.compressed_size);
                            else if (response.tx_ratio != null) compressedSize = Math.max(0, Math.floor(orig * Number(response.tx_ratio)));
                        }
                        const savedPct = Math.max(0, Math.min(100, (1 - (compressedSize / Math.max(1, orig))) * 100));
                        const savedStr = savedPct.toFixed(1);
                        const factor = compressedSize > 0 ? (orig / compressedSize) : Infinity;

                        log(`Uploaded ${item.file.name} - Saved ${savedStr}% (~${isFinite(factor) ? factor.toFixed(1) : 'âˆž'}x smaller)`, 'success');
                        showToast(`Uploaded: saved ${savedStr}% (~${isFinite(factor) ? factor.toFixed(1) : 'âˆž'}x smaller)`, 'success');

                        // Update aggregate stats
                        updateAggregates(orig, compressedSize);
                        compressionDiagnostic(orig, compressedSize);

                        // Remove from queue
                        removeFromUpload(item.id);

                        done = true;
                        resolve(response);
                    } catch (err) {
                        if (!done) {
                            done = true;
                            item.status = 'failed';
                            log(`Upload failed ${item.file.name}: ${err}`, 'error');
                            showToast('Upload failed', 'error');
                            reject(err);
                        }
                    }
                });

                xhr.addEventListener('error', async () => {
                    if (done) return;
                    done = true;
                    if (attempt < 2) {
                        log(`Retrying ${item.file.name} after network error`, 'info');
                        try {
                            const res = await uploadFile(item, attempt+1);
                            resolve(res); return;
                        } catch (e) { /* fall through */ }
                    }
                    item.status = 'failed';
                    log(`Failed to upload ${item.file.name}`, 'error');
                    showToast('Upload failed', 'error');
                    reject(new Error('network error'));
                });

                xhr.open('POST', '/objects');
                xhr.responseType = 'json';
                xhr.send(formData);
            });
        }

        // Update upload progress
        function updateUploadProgress(percent, loaded, total, startTime) {
          document.getElementById('uploadProgressFill').style.width = percent + '%';
          document.getElementById('uploadPercent').textContent = percent.toFixed(1) + '%';
          const elapsed = (Date.now() - startTime) / 1000;
          const speed = loaded / elapsed;
          const s = smoothSpeed(speed);
          document.getElementById('uploadSpeed').textContent = formatSpeed(speed);
          document.getElementById('transferSpeed').textContent = formatSpeed(s);
          const remaining = total - loaded;
          const eta = remaining / Math.max(1,speed);
          document.getElementById('uploadETA').textContent = 'ETA: ' + formatTime(eta);
        }

        // Start download
        async function startDownload() {
            const url = document.getElementById('downloadUrl').value;
            const sourceNode = document.getElementById('sourceNode').value;
            
            if (!url) {
                showToast('Please enter a file URL or ID', 'error');
                return;
            }

            document.getElementById('downloadProgress').style.display = 'block';
            
            try {
                const response = await fetch('/api/transfer/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: url,
                        source_node: sourceNode || null
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const filename = response.headers.get('X-Filename') || 'download';
                    
                    // Create download link
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    a.click();
                    
                    log(`Downloaded ${filename}`, 'success');
                    showToast('Download complete!', 'success');
                } else {
                    throw new Error('Download failed');
                }
            } catch (error) {
                log(`Download error: ${error}`, 'error');
                showToast('Download failed', 'error');
            }
            
            document.getElementById('downloadProgress').style.display = 'none';
        }

        // Handle transfer updates from WebSocket
        function handleTransferUpdate(data) {
            if (data.type === 'progress') {
                // Update progress bars
                if (data.direction === 'upload') {
                    updateUploadProgress(data.percent, data.loaded, data.total, data.startTime);
                } else {
                    // Minimal download handling to keep speed stat current
                    updateDownloadProgress(data.percent, data.loaded, data.total, data.startTime);
                }
            } else if (data.type === 'complete') {
                log(`Transfer complete: ${data.filename}`, 'success');
            } else if (data.type === 'transfers') {
                // Periodic transfer snapshot from server
                try {
                    const snap = data.transfers || {};
                    const values = Object.values(snap);
                    const running = values.filter(v => (v.state || '').toLowerCase() === 'running');
                    document.getElementById('activeTransfers').textContent = String(running.length);
                    // Do not override compression ratio here; it's session aggregate from updateAggregates().
                } catch {}
            }
        }

        // Aggregate stats (session)
        function updateAggregates(origBytes, compressedBytes) {
            totalOriginalBytes += Math.max(0, Number(origBytes)||0);
            totalCompressedBytes += Math.max(0, Number(compressedBytes)||0);
            totalSavedBytes = Math.max(0, totalOriginalBytes - totalCompressedBytes);
            // Maintain legacy totalTransferred as original bytes sum
            totalTransferred = totalOriginalBytes;
            const pct = totalOriginalBytes > 0 ? (1 - (totalCompressedBytes / totalOriginalBytes)) * 100 : 0;
            document.getElementById('totalTransferred').textContent = formatFileSize(totalOriginalBytes);
            document.getElementById('spaceSaved').textContent = formatFileSize(totalSavedBytes);
            const su = document.getElementById('storageUsed');
            if (su) su.textContent = formatFileSize(totalCompressedBytes);
            document.getElementById('compressionRatio').textContent = pct.toFixed(1) + '%';
        }

        // Compression diagnostics: warn if savedPct < threshold
const LOW_COMPRESSION_THRESHOLD = 5; // percent saved
function compressionDiagnostic(orig, compressed){
  if (!orig || !compressed) return;
  const savedPct = (1 - (compressed/Math.max(1,orig)))*100;
  if (savedPct < LOW_COMPRESSION_THRESHOLD){
    showToast('Low compression ('+savedPct.toFixed(1)+'%) - data may be already compressed or arithmetic mode off','info');
  }
}

        // Utility functions
        function formatFileSize(bytes) {
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];
        }

        function formatSpeed(bytesPerSecond) {
            return formatFileSize(bytesPerSecond) + '/s';
        }

        function formatTime(seconds) {
            if (seconds < 60) return Math.round(seconds) + 's';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.round(seconds % 60);
            return minutes + 'm ' + secs + 's';
        }

        // Download progress stub (UI lacks separate bar; we still surface speed)
        function updateDownloadProgress(percent, loaded, total, startTime) {
          if (!startTime) startTime = Date.now();
          const elapsed = Math.max(0.05, (Date.now() - startTime) / 1000);
          const speed = loaded / elapsed;
          const s = smoothSpeed(speed);
          const el = document.getElementById('transferSpeed');
          if (el) el.textContent = formatSpeed(s);
        }

        // Logging
        function log(message, type = 'info') {
            const logContent = document.getElementById('activityLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-message log-${type}">${message}</span>
            `;
            
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function clearLog() {
            document.getElementById('activityLog').innerHTML = '';
        }

        // Toast notifications
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            const icon = { success: 'âœ“', error: 'âœ•', info: 'â„¹' }[type];
            // Security: escape message to avoid HTML injection
            const safe = escapeHTML(String(message || ''));
            toast.innerHTML = `
                <span style="font-size: 1.5rem;">${icon}</span>
                <span>${safe}</span>
            `;
            document.getElementById('toastContainer').appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Mode switching
        function setMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Switch UI based on mode
            if (mode === 'receive') {
                log('Switched to receive mode - listening for incoming transfers', 'info');
                // Start receiver service
                startReceiver();
            } else if (mode === 'relay') {
                log('Switched to relay mode - acting as transfer relay', 'info');
                // Start relay service
                startRelay();
            } else {
                log('Switched to transfer mode', 'info');
            }
        }

        // Start receiver service
        async function startReceiver() {
            try {
                const response = await fetch('/api/transfer/receive', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showToast('Receiver started - ready for incoming files', 'success');
                }
            } catch (error) {
                showToast('Failed to start receiver', 'error');
            }
        }

        // Start relay service
        async function startRelay() {
            try {
                const response = await fetch('/api/transfer/relay', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showToast('Relay started - bridging transfers', 'success');
                }
            } catch (error) {
                showToast('Failed to start relay', 'error');
            }
        }

        // --------- FS UI helpers ---------
        async function addSource() {
            const device = document.getElementById('srcDevice').value.trim();
            const label = document.getElementById('srcLabel').value.trim();
            const watch = document.getElementById('srcWatch').checked;
            if (!device || !label) {
                showToast('Device and label required', 'error');
                return;
            }
            try {
                const res = await fetch('/api/fs/sources', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device, label, watch })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'add source failed');
                addCommandSuggestion(data.suggested_command, data.job_id, 'add_source');
                showToast('Source added. Run the suggested command to apply.', 'info');
                await refreshSources();
            } catch (e) {
                showToast('Add source failed: ' + e.message, 'error');
            }
        }

        async function createWorkspace() {
            const name = document.getElementById('wsName').value.trim();
            const lowersStr = document.getElementById('wsLowers').value.trim();
            if (!name || !lowersStr) {
                showToast('Workspace name and lowers required', 'error');
                return;
            }
            const lowers = lowersStr.split(',').map(s => s.trim()).filter(Boolean);
            try {
                const res = await fetch('/api/fs/workspaces', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, lowers })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'create workspace failed');
                addCommandSuggestion(data.suggested_command, data.job_id, 'create_workspace');
                showToast('Workspace created (pending). Run the suggested command to mount.', 'info');
                await refreshWorkspaces();
            } catch (e) {
                showToast('Create workspace failed: ' + e.message, 'error');
            }
        }

        async function refreshSources() {
            try {
                const res = await fetch('/api/fs/sources');
                const data = await res.json();
                fsSources = data.sources || [];
                renderSources();
            } catch (e) {
                // ignore
            }
        }

        async function refreshWorkspaces() {
            try {
                const res = await fetch('/api/fs/workspaces');
                const data = await res.json();
                fsWorkspaces = data.workspaces || [];
                renderWorkspaces();
            } catch (e) {
                // ignore
            }
        }

        function renderSources() {
            const el = document.getElementById('sourcesList');
            el.innerHTML = '';
            fsSources.forEach(s => {
                const row = document.createElement('div');
                row.className = 'file-item';
                const status = s.status || 'unknown';
                const error = s.error ? `<div style="color:#f66; font-size:0.8rem;">${s.error}</div>` : '';
                row.innerHTML = `
                    <div class="file-info">
                      <span class="file-icon">[FILE]</span>
                      <div class="file-details">
                        <div class="file-name">${s.label} <span style="color:#888;font-weight:400;">(${status})</span></div>
                        <div class="file-meta">dev=${s.device || '-'} â€¢ host=${s.host_mount || '-'} â€¢ pfs=${s.pfspath || '-'} ${error}</div>
                      </div>
                    </div>
                    <div class="file-actions">
                      <button class="btn btn-secondary" onclick="syncSource('${s.label}')">Sync</button>
                      <button class="btn btn-danger" onclick="removeSource('${s.label}')">Remove</button>
                    </div>
                `;
                el.appendChild(row);
            });
        }

        async function syncSource(label) {
            try {
                const res = await fetch('/api/fs/sources/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ label })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'sync failed');
                addCommandSuggestion(data.suggested_command, data.job_id, 'sync_source');
                showToast('Sync suggested. Run the command in terminal.', 'info');
                await refreshSources();
            } catch (e) {
                showToast('Sync failed: ' + e.message, 'error');
            }
        }

        async function removeSource(label) {
            try {
                const res = await fetch('/api/fs/sources/' + encodeURIComponent(label), { method: 'DELETE' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'remove failed');
                addCommandSuggestion(data.suggested_command, data.job_id, 'remove_source');
                showToast('Removal suggested. Run the unmount command.', 'info');
                await refreshSources();
            } catch (e) {
                showToast('Remove failed: ' + e.message, 'error');
            }
        }

        function renderWorkspaces() {
            const el = document.getElementById('workspacesList');
            el.innerHTML = '';
            fsWorkspaces.forEach(w => {
                const row = document.createElement('div');
                row.className = 'file-item';
                const status = w.status || 'unknown';
                const lowers = (w.lowers || []).join(', ');
                const error = w.error ? `<div style="color:#f66; font-size:0.8rem;">${w.error}</div>` : '';
                row.innerHTML = `
                    <div class="file-info">
                      <span class="file-icon">[WS]</span>
                      <div class="file-details">
                        <div class="file-name">${w.name} <span style=\"color:#888;font-weight:400;\">(${status})</span></div>
                        <div class="file-meta">lowers=${lowers || '-'} â€¢ mount=${w.pfspath || '-'} â€¢ upper=${w.upperdir || '-'} ${error}</div>
                      </div>
                    </div>
                    <div class="file-actions">
                      <button class="btn btn-danger" onclick="removeWorkspace('${w.name}')">Remove</button>
                    </div>
                `;
                el.appendChild(row);
            });
        }

        async function removeWorkspace(name) {
            try {
                const res = await fetch('/api/fs/workspaces/' + encodeURIComponent(name), { method: 'DELETE' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'remove workspace failed');
                addCommandSuggestion(data.suggested_command, data.job_id, 'remove_workspace');
                showToast('Workspace removal suggested. Run the command.', 'info');
                await refreshWorkspaces();
            } catch (e) {
                showToast('Remove workspace failed: ' + e.message, 'error');
            }
        }

        function addCommandSuggestion(cmd, jobId, kind) {
            cmdHistory.push({ cmd, jobId, kind, ts: new Date().toISOString() });
            const el = document.getElementById('commandsList');
            const row = document.createElement('div');
            row.className = 'file-item';
            row.innerHTML = `
                <div class="file-info">
                  <span class="file-icon">$</span>
                  <div class="file-details">
                    <div class="file-name">${kind} <span style=\"color:#888;font-weight:400;\">job=${jobId}</span></div>
                    <div class="file-meta" style="font-family: 'Courier New', monospace;">${escapeHTML(cmd)}</div>
                  </div>
                </div>
                <div class="file-actions">
                  <button class="btn btn-secondary" onclick="runInTerminal('${b64(cmd)}')">Run</button>
                  <button class="btn btn-secondary" onclick="copyToClipboard('${b64(cmd)}')">Copy</button>
                </div>
            `;
            el.prepend(row);
        }

        function b64(s) { return btoa(unescape(encodeURIComponent(s))); }
        function fromb64(s) { return decodeURIComponent(escape(atob(s))); }
        function copyToClipboard(b64cmd) {
            const cmd = fromb64(b64cmd);
            navigator.clipboard.writeText(cmd).then(() => showToast('Copied command', 'success')).catch(() => showToast('Copy failed', 'error'));
        }
        function escapeHTML(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

        // --------- Peers (minimal) ---------
        let peersPermanent = [];
        let peersSession = [];
        function savePeersSession() { sessionStorage.setItem('pfs_cluster_session', JSON.stringify(peersSession || [])); }
        function loadPeersSession() { try { peersSession = JSON.parse(sessionStorage.getItem('pfs_cluster_session')||'[]')||[]; } catch { peersSession = []; } }
        function parseUserHost(s) {
            if (!s) return { user: null, host: '' };
            if (s.includes('@')) { const [u,h] = s.split('@'); return { user: u || null, host: h || '' }; }
            return { user: null, host: s };
        }
        async function refreshPeers() {
            try {
                const r = await fetch('/cluster/hosts');
                if (r.ok) { peersPermanent = await r.json(); } else { peersPermanent = []; }
            } catch { peersPermanent = []; }
            loadPeersSession();
            renderPeers();
        }
        function renderPeers() {
            const el = document.getElementById('peersList');
            if (!el) return;
            el.innerHTML = '';
            const addRow = (h, persisted, idx) => {
                const row = document.createElement('div');
                row.className = 'file-item';
                row.innerHTML = `
                    <div class="file-info">
                      <span class="file-icon">[PEER]</span>
                      <div class="file-details">
                        <div class="file-name">${(h.user? (h.user+'@') : '') + h.host} <span style="color:#888;font-weight:400;">:${h.ws_port||8811}</span></div>
                        <div class="file-meta">persisted=${persisted ? 'yes' : 'no'}</div>
                      </div>
                    </div>
                    <div class="file-actions">
                      ${persisted ? '' : `<button class="btn btn-danger" onclick="removeSessionPeer(${idx})">Remove</button>`}
                    </div>`;
                el.appendChild(row);
            };
            for (const h of (peersPermanent||[])) addRow(h, true, -1);
            peersSession.forEach((h, i) => addRow(h, false, i));
        }
        async function probePeer() {
            const hostStr = (document.getElementById('peerHost')||{}).value || '';
            const ws = parseInt((document.getElementById('peerWs')||{}).value || '8811', 10);
            const { user, host } = parseUserHost(hostStr.trim());
            if (!host) { showToast('Host is required', 'error'); return; }
            try {
                const r = await fetch('/cluster/hosts/probe', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ label: host, host, user, ws_port: ws, https_port: ws, quic_port: 8853 }) });
                const j = await r.json();
                showToast(j.reachable ? 'SSH reachable' : 'SSH not reachable', j.reachable ? 'success' : 'info');
            } catch(e) {
                showToast('Probe failed: ' + e.message, 'error');
            }
        }
        async function addPeer() {
            const hostStr = (document.getElementById('peerHost')||{}).value || '';
            const ws = parseInt((document.getElementById('peerWs')||{}).value || '8811', 10);
            const persist = !!((document.getElementById('peerPersist')||{}).checked);
            const { user, host } = parseUserHost(hostStr.trim());
            if (!host) { showToast('Host is required', 'error'); return; }
            const entry = { label: host, host, user, ws_port: ws, https_port: ws, quic_port: 8853 };
            if (persist) {
                try {
                    const r = await fetch('/cluster/hosts', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(entry) });
                    if (r.ok) {
                        showToast('Peer persisted', 'success');
                        await refreshPeers();
                        return;
                    } else {
                        const j = await r.json().catch(()=>({}));
                        showToast('SSH unreachable; adding as session peer', 'info');
                        loadPeersSession(); peersSession.push(entry); savePeersSession(); renderPeers();
                        return;
                    }
                } catch (e) {
                    showToast('Persist failed; adding as session peer', 'info');
                    loadPeersSession(); peersSession.push(entry); savePeersSession(); renderPeers();
                    return;
                }
            } else {
                loadPeersSession(); peersSession.push(entry); savePeersSession(); renderPeers();
                showToast('Session peer added', 'success');
            }
        }
        function removeSessionPeer(idx) {
            loadPeersSession();
            if (idx >= 0 && idx < peersSession.length) {
                peersSession.splice(idx, 1);
                savePeersSession();
                renderPeers();
                showToast('Removed session peer', 'info');
            }
        }

        // Start folder transfer (server-side via /xfer)
        async function startFolderTransfer() {
            const src = document.getElementById('folderSrcPath').value.trim();
            const host = document.getElementById('folderDstHost').value.trim();
            const dstPath = document.getElementById('folderDstPath').value.trim();
            if (!src || !host) { showToast('Source path and destination host required', 'error'); return; }
            try {
                const body = {
                    src: { endpoint: { host: window.location.hostname, ws_port: parseInt((new URL(window.location.href)).port || (window.location.protocol==='https:'?'8811':'8811'), 10) || 8811 }, path: src },
                    dst: { host, ws_port: 8811 },
                    dst_path: dstPath || null,
                    timeout_s: 30.0
                };
                const res = await fetch('/xfer', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'xfer failed');
                showToast('Folder transfer started', 'success');
                log('Folder transfer started: ' + JSON.stringify(data), 'info');
            } catch (e) {
                showToast('Folder transfer failed: ' + e.message, 'error');
            }
        }

        // --------- Terminal WS (basic) ---------
        function termConnect() {
            if (termWS && termConnected) return;
            termWS = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/terminal');
            // Receive raw SSH output as binary frames to avoid any HTML-entity encoding issues
            termWS.binaryType = 'arraybuffer';
            termWS.onopen = () => {
                const host = (document.getElementById('termHost')||{}).value || 'localhost';
                const user = (document.getElementById('termUser')||{}).value || 'punk';
                               const password = (document.getElementById('termPass')||{}).value || undefined;
                termWS.send(JSON.stringify({ type: 'connect', host, user, password }));
            };
            termWS.onmessage = (ev) => {
                // Control messages arrive as JSON text; terminal output arrives as ArrayBuffer
                if (typeof ev.data === 'string') {
                    try {
                        const msg = JSON.parse(ev.data);
                        if (msg.type === 'connected') { appendTerm(`\n[connected] ${msg.message}\n`); termConnected = true; }
                        else if (msg.type === 'error') { appendTerm(`\n[error] ${msg.message}\n`); }
                        else if (msg.type === 'host_key') { showToast(`Host ${msg.host} fingerprint: ${msg.fingerprint}`, 'info'); }
                        // If older servers still send output via JSON, support it too
                        else if (msg.type === 'output') { appendTerm(msg.data || ''); }
                    } catch {
                        appendTerm(ev.data);
                    }
                } else if (ev.data instanceof ArrayBuffer) {
                    try {
                        const s = new TextDecoder('utf-8').decode(ev.data);
                        appendTerm(s);
                    } catch {
                        // Fallback: try Blob route (should not happen with binaryType=arraybuffer)
                        appendTerm('[binary data]\n');
                    }
                } else if (ev.data && ev.data.arrayBuffer) {
                    // Blob case if binaryType was not honored
                    ev.data.arrayBuffer().then(buf => {
                        const s = new TextDecoder('utf-8').decode(buf);
                        appendTerm(s);
                    }).catch(() => appendTerm('[binary data]\n'));
                }
            };
            termWS.onclose = () => { termConnected = false; appendTerm('\n[disconnected]\n'); };
        }
        function termDisconnect() { try { termWS && termWS.close(); } catch {} termConnected = false; }
        function termSend() {
            const input = document.getElementById('termInput');
            if (!input) return;
            const text = input.value + '\n';
            if (termWS && termConnected) termWS.send(JSON.stringify({ type: 'input', data: text }));
            input.value='';
        }
        function termPaste(b64cmd) {
            const cmd = fromb64(b64cmd) + '\n';
            if (termWS && termConnected) termWS.send(JSON.stringify({ type: 'input', data: cmd }));
            appendTerm(`$ ${fromb64(b64cmd)}\n`);
        }
        async function runInTerminal(b64cmd) {
            // Ensure terminal is connected, then paste+execute
            if (!termConnected) {
                termConnect();
                // wait briefly for connection
                await new Promise(r => setTimeout(r, 800));
            }
            termPaste(b64cmd);
        }
        function appendTerm(s) {
            const out = document.getElementById('termOutput');
            if (!out) return;
            out.textContent += s;
            out.scrollTop = out.scrollHeight;
        }

        // Refresh files list using existing /objects endpoint
        async function refreshFiles() {
            try {
                const response = await fetch('/objects');
                if (!response.ok) throw new Error('Failed to fetch files');
                const objects = await response.json();
                
                const filesList = document.getElementById('myFilesList');
                if (objects.length === 0) {
                    filesList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">No files uploaded yet</div>';
                    document.getElementById('totalFiles').textContent = '0';
                    document.getElementById('spaceSaved').textContent = '0 GB';
                    return;
                }
                
                // Update storage stats
                document.getElementById('totalFiles').textContent = objects.length;
                
                // Calculate total space saved (original size - compressed size)
                let totalOriginal = 0;
                let totalCompressed = 0;
                objects.forEach(obj => {
                    totalOriginal += obj.size || 0;
                    // With PacketFS native arithmetic mode, compressed size is typically 1-5% of original
                    totalCompressed += (obj.compressed_size || obj.size * 0.02);
                });
                
                const spaceSaved = totalOriginal - totalCompressed;
                document.getElementById('spaceSaved').textContent = formatFileSize(spaceSaved);
                
                filesList.innerHTML = '';
                objects.forEach(obj => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    
                    // Calculate compression for this file
                    const compressedSize = obj.compressed_size || obj.size * 0.02;
                    const compressionRatio = ((1 - (compressedSize / obj.size)) * 100).toFixed(1);
                    const shortSha = (obj.sha256||'').substring(0, 8);
                    const displayName = obj.filename || (shortSha ? `file-${shortSha}` : (obj.object_id||'').replace('sha256:', '').substring(0, 8));
                    
                    fileItem.innerHTML = `
                        <div class="file-info" style="gap:0.5rem;">
                            <span class="file-icon">â€¢</span>
                            <div class="file-details" style="min-width:0;">
                                <div class="file-name" title="${displayName}">${displayName}</div>
                                <div class="file-meta">${formatFileSize(obj.size)} â†’ ${formatFileSize(compressedSize)} â€¢ Saved ${compressionRatio}% â€¢ sha=${shortSha}â€¦</div>
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="btn btn-secondary" onclick="downloadObject('${obj.object_id}')">Download</button>
                            <button class="btn btn-primary" onclick="sendObjectWS('${obj.object_id}')">Send (WSx4)</button>
                        </div>
                    `;
                    filesList.appendChild(fileItem);
                });
            } catch (error) {
                log('Failed to refresh files: ' + error, 'error');
            }
        }

        // Download object using existing /objects/{id}/bytes endpoint
        async function downloadObject(objectId) {
            try {
                // Fetch object metadata to get the friendly filename
                let filename = null;
                try {
                    const metaRes = await fetch(`/objects`);
                    if (metaRes.ok) {
                        const arr = await metaRes.json();
                        const hit = (arr||[]).find(o => o.object_id === objectId);
                        if (hit && hit.filename) filename = hit.filename;
                    }
                } catch {}
                const response = await fetch(`/objects/${objectId}/bytes`);
                if (!response.ok) throw new Error('Download failed');
                const blob = await response.blob();
                if (!filename) filename = objectId.replace(':', '_') + '.bin';
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                a.click();
                
                log(`Downloaded ${filename}`, 'success');
                showToast('Download complete!', 'success');
            } catch (error) {
                log(`Download error: ${error}`, 'error');
                showToast('Download failed', 'error');
            }
        }

        // Send object via PacketFS arithmetic WS (uses multi-WS by default)
        async function sendObjectWS(objectId){
            try{
                const ipr = await fetch(`/objects/${encodeURIComponent(objectId)}/iprog`);
                if(!ipr.ok){ showToast('No IPROG available for object','error'); return; }
                const iprog = await ipr.json();
                if (!window.pfsSendIprogMulti){ showToast('Arithmetic client not loaded','error'); return; }
                const ch = Number(localStorage.getItem('PFS_WS_CHANNELS')||'4')||4;
                const res = await window.pfsSendIprogMulti(iprog, 'ui-'+Date.now(), ch);
                if (res && res.ok){ showToast('Arithmetic send complete','success'); } else { showToast('Arithmetic send failed','error'); }
            } catch(e){ showToast('Arithmetic send error: '+(e&&e.message?e.message:String(e)),'error'); }
        }

        // Rotating taglines - changes every 24 hours based on day of year
        function setRotatingTagline() {
            const taglines = [
                "Powered by BLACK MAGIC",
                "Powered by MATH",
                "Physics is just a suggestion",
                "Your files exist as pure thought",
                "Compression through dark arithmetic",
                "Storage in the mathematical void",
                "Where bytes go to disappear",
                "Infinite space, zero mass",
                "Files become equations",
                "Storage through sorcery",
                "99% compression, 100% wizardry",
                "Data transcends reality",
                "Arithmetic voodoo at work"
            ];
            
            // Use day of year to pick tagline (changes daily)
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 0);
            const diff = now - start;
            const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
            const taglineIndex = dayOfYear % taglines.length;
            
            const taglineElement = document.getElementById('brandTagline');
            if (taglineElement) {
                taglineElement.textContent = taglines[taglineIndex];
            }
        }

        // --- Pack folder to .tar in OPFS, then enqueue as a single file in Uppy ---
        async function packFolderAsTarAndQueue(fileList) {
            if (!fileList || fileList.length === 0) return;
            const root = await getOPFSRoot();
            if (!root) throw new Error('OPFS unavailable for packing');
            const now = new Date();
            const tarName = `folder_${now.toISOString().replace(/[:.]/g,'-')}.tar`;
            // Create or overwrite
            try { await root.removeEntry(tarName); } catch {}
            const fh = await root.getFileHandle(tarName, {create:true});
            const writable = await fh.createWritable();

            // Helper: write chunk
            async function write(buf) {
                if (!buf || buf.byteLength === 0) return;
                await writable.write(new Blob([buf]));
                packedBytes += buf.byteLength;
                updatePackingProgress();
            }

            // Tar header builder (USTAR)
            function padTo512(n) { return (512 - (n % 512)) % 512; }
            function encodeOctal(value, length) {
                const s = value.toString(8);
                const pad = '0'.repeat(Math.max(0, length - 1 - s.length));
                return (pad + s + '\0').slice(0, length);
            }
            function checksum(header) {
                let sum = 0;
                for (let i=0;i<512;i++) sum += header[i];
                return sum;
            }
            function buildHeader(name, size, mode=0o644, mtime=Math.floor(Date.now()/1000), typeflag='0'){
                const buf = new Uint8Array(512);
                const enc = new TextEncoder();
                const set = (off, str) => { buf.set(enc.encode(str), off); };
                set(0, name.length>100?name.slice(0,100):name);
                set(100, encodeOctal(mode,8));
                set(108, encodeOctal(0,8)); // uid
                set(116, encodeOctal(0,8)); // gid
                set(124, encodeOctal(size,12));
                set(136, encodeOctal(mtime,12));
                // checksum field: spaces
                for (let i=148;i<156;i++) buf[i]=0x20;
                set(156, typeflag);
                set(157, '');
                set(257, 'ustar\0');
                set(263, '00');
                const sum = checksum(buf);
                set(148, encodeOctal(sum,8));
                return buf;
            }

            // Precompute total for progress (approx)
            let totalBytes = 0;
            Array.from(fileList).forEach(f => {
                const name = (f.webkitRelativePath && f.webkitRelativePath.length ? f.webkitRelativePath : f.name);
                const s = Number(f.size||0);
                totalBytes += 512 + s + padTo512(s);
            });
            // Two 512-byte blocks at end
            totalBytes += 1024;
            let packedBytes = 0;
            function updatePackingProgress(){
                const overall = document.getElementById('overallProgress');
                const fill = document.getElementById('overallProgressFill');
                const label = document.getElementById('overallPercent');
                if (overall && fill && label) {
                    overall.style.display = 'block';
                    const pct = totalBytes>0 ? (packedBytes/totalBytes)*100 : 0;
                    fill.style.width = String(pct.toFixed ? pct.toFixed(1) : pct) + '%';
                    label.textContent = `Packing ${pct.toFixed ? pct.toFixed(1) : pct}%`;
                }
            }

            for (const f of Array.from(fileList)) {
                const name = (f.webkitRelativePath && f.webkitRelativePath.length ? f.webkitRelativePath : f.name);
                const size = Number(f.size||0);
                const hdr = buildHeader(name, size);
                await write(hdr);
                const reader = f.stream().getReader();
                while (true) {
                    const {value, done} = await reader.read();
                    if (done) break;
                    await write(value);
                }
                const pad = padTo512(size);
                if (pad) await write(new Uint8Array(pad));
            }
            // Two empty blocks to finish
            await write(new Uint8Array(1024));
            await writable.close();

            // Queue packed tar into Uppy
            const tarBlob = await fh.getFile();
            const relName = tarName;
            window.uppy.addFile({
                name: relName,
                type: 'application/x-tar',
                data: tarBlob,
                meta: { relativePath: relName }
            });
            // Reset progress label
            const overall = document.getElementById('overallProgress');
            if (overall) overall.style.display = 'none';
            const ub = document.getElementById('uploadBtn');
            if (ub) ub.disabled = false;
            showToast('Packed folder into tar and queued for upload', 'success');
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            setRotatingTagline();
            initWebSocket();
            await refreshPeers();
            await refreshFiles();
            // Poll blob status for progressive fill
            async function pollBlob() {
                try {
                    const r = await fetch('/blob/status');
                    if (!r.ok) throw new Error('blob status '+r.status);
                    const j = await r.json();
                    const fill = j.fill || {};
                    const prep = document.getElementById('blobPrep');
                    const fillDiv = document.getElementById('blobPrepFill');
                    const pctSpan = document.getElementById('blobPrepPct');
                    const label = document.getElementById('blobPrepLabel');
                    const etaEl = document.getElementById('blobPrepEta');
                    const startBtn = document.getElementById('blobPrepStartBtn');
                    if (fill.status === 'running') {
                        if (prep.style.display !== 'block') prep.style.display = 'block';
                        const pct = Math.max(0, Math.min(1, Number(fill.pct || 0)));
                        fillDiv.style.width = (pct*100).toFixed(1)+'%';
                        pctSpan.textContent = (pct*100).toFixed(1)+'%';
                        label.textContent = 'Charging hypercannonsâ€¦';
                        if (typeof fill.eta_s === 'number' && isFinite(fill.eta_s)) {
                            etaEl.style.display = 'block';
                            const eta = fill.eta_s;
                            if (eta > 120) {
                                etaEl.textContent = 'ETA: ~'+(eta/60).toFixed(1)+'m';
                            } else {
                                etaEl.textContent = 'ETA: ~'+eta.toFixed(1)+'s';
                            }
                        } else {
                            etaEl.style.display = 'none';
                        }
                        startBtn.style.display = 'none';
                    } else if (fill.status === 'done') {
                        if (prep.style.display !== 'none') {
                            fillDiv.style.width = '100%';
                            pctSpan.textContent = '100%';
                            label.textContent = 'Ready';
                            etaEl.style.display = 'none';
                            setTimeout(()=>{ prep.style.display='none'; }, 1500);
                        }
                        startBtn.style.display = 'none';
                    } else if (fill.status === 'error') {
                        prep.style.display = 'block';
                        label.textContent = 'Error preparing blob';
                        startBtn.style.display = 'block';
                        etaEl.style.display = 'none';
                    } else {
                        // Not started yet â€” allow manual start
                        prep.style.display = 'block';
                        label.textContent = 'Idle â€“ press Start to arm';
                        pctSpan.textContent = '0%';
                        fillDiv.style.width = '0%';
                        startBtn.style.display = 'block';
                        etaEl.style.display = 'none';
                    }
                } catch(e) { /* ignore */ }
                finally { setTimeout(pollBlob, 1000); }
            }
            pollBlob();
            // Manual start
            const startBtn = document.getElementById('blobPrepStartBtn');
            if (startBtn) {
                startBtn.addEventListener('click', async () => {
                    startBtn.disabled = true;
                    try {
                        const r = await fetch('/blob/fill', {method:'POST'});
                        if (!r.ok) throw new Error('start failed '+r.status);
                    } catch(e) {
                        console.error(e);
                    } finally {
                        setTimeout(()=>{ startBtn.disabled = false; }, 1500);
                    }
                });
            }
            
            // Initialize Uppy with existing /objects endpoint
            import('https://releases.transloadit.com/uppy/v5.1.1/uppy.min.mjs').then(({ Uppy, Dashboard, XHRUpload }) => {
                const uppy = new Uppy({ autoProceed: false })
                    .use(Dashboard, { 
                        target: '#uppy-dashboard', 
                        inline: true, 
                        height: 400,
                        showProgressDetails: true,
                        proudlyDisplayPoweredByUppy: false,
                        theme: 'dark'
                    })
                    .use(XHRUpload, {
                        endpoint: '/objects',
                        fieldName: 'file',
                        formData: true,
                        limit: 8,
                        withCredentials: false,
                        // Increase/disable client-side timeout to prevent false "network error"
                        // on large or slow uploads (default is 30s). 0 disables timeout.
                        timeout: 0
                    });
                
                // Expose for global handlers
                window.uppy = uppy;

                // Hook explicit pickers
                const filePicker = document.getElementById('filePicker');
                const folderPicker = document.getElementById('folderPicker');
                if (filePicker) {
                    filePicker.addEventListener('change', (e) => addFilesToUppy(e.target.files));
                }
                if (folderPicker) {
                    folderPicker.addEventListener('change', async (e) => {
                        const files = e.target.files;
                        const pack = !!(document.getElementById('packFolderTar')||{}).checked;
                        if (pack) {
                            try {
                                await packFolderAsTarAndQueue(files);
                            } catch (err) {
                                showToast('Pack folder failed: ' + (err && err.message ? err.message : err), 'error');
                            }
                        } else {
                            addFilesToUppy(files);
                        }
                    });
                }

                uppy.on('upload-success', (file, response) => {
                    const body = response && response.body ? response.body : {};
                    const objectId = body.object_id || '(unknown)';
                    const originalName = (body.filename || file.meta && file.meta.name) || file.name;
                    const orig = Number(file.size || 0);
                    let compressedSize = orig;
                    if (body && typeof body === 'object') {
                        if (body.compressed_size != null) compressedSize = Number(body.compressed_size);
                        else if (body.tx_ratio != null) compressedSize = Math.max(0, Math.floor(orig * Number(body.tx_ratio)));
                    }
                    const savedPct = Math.max(0, Math.min(100, (1 - (compressedSize / Math.max(1, orig))) * 100));
                    const savedStr = savedPct.toFixed(1);
                    const factor = compressedSize > 0 ? (orig / compressedSize) : Infinity;
                    log(`Uploaded ${originalName} (id=${objectId}) - Saved ${savedStr}% (~${isFinite(factor) ? factor.toFixed(1) : 'âˆž'}x smaller)`, 'success');
                    showToast(`Uploaded ${originalName}: saved ${savedStr}% (~${isFinite(factor) ? factor.toFixed(1) : 'âˆž'}x smaller)`, 'success');
                    updateAggregates(orig, compressedSize);
                    compressionDiagnostic(orig, compressedSize);
                    refreshFiles();
                    // Remove file from Uppy state after successful upload so subsequent uploads
                    // (manual re-click of Start Upload) don't re-send the same file.
                    try { if (window.uppy) window.uppy.removeFile(file.id); } catch {}
                });

                // Aggregate progress for Uppy uploads
                uppy.on('progress', (pct) => {
                    const overall = document.getElementById('overallProgress');
                    const fill = document.getElementById('overallProgressFill');
                    const label = document.getElementById('overallPercent');
                    if (overall && fill && label) {
                        overall.style.display = 'block';
                        fill.style.width = String(Math.max(0, Math.min(100, pct))) + '%';
                        label.textContent = String(Math.max(0, Math.min(100, pct.toFixed ? pct.toFixed(1) : pct))) + '%';
                    }
                });
                uppy.on('complete', () => {
                    const overall = document.getElementById('overallProgress');
                    if (overall) overall.style.display = 'none';
                    // Show session aggregate stats summary
                    try {
                        const pct = totalOriginalBytes > 0 ? (1 - (totalCompressedBytes / totalOriginalBytes)) * 100 : 0;
                        showToast(`Session: ${formatFileSize(totalOriginalBytes)} original, saved ${formatFileSize(totalSavedBytes)} (${pct.toFixed(1)}% reduction)`, 'info');
                    } catch {}
                });
                
                // Auto-retry once per file on error, and log richer diagnostics
                uppy.on('upload-error', (file, error, resp) => {
                    try {
                        const status = (resp && (resp.status || resp.statusCode)) || 0;
                        const body = resp && (resp.body || resp.data);
                        const detail = body && (body.detail || body.message || (typeof body === 'string' ? body : JSON.stringify(body).slice(0, 200)));
                        const emsg = (error && (error.message || String(error))) || 'error';
                        const hint = status === 401 ? ' (unauthorized: sign in or disable auth)' : status === 413 ? ' (payload too large)' : !status ? ' (network/CORS/timeout)' : '';
                        console.warn('[Uppy] upload-error', { status, emsg, detail, resp });
                        log(`Upload error${hint}: ${emsg}${status ? ' [HTTP '+status+']' : ''}${detail ? ' â€” '+detail : ''}`, 'error');
                    } catch {}
                    // Automatic single retry already; add second (final) retry for resilience.
                    if (file && !file.__retriedOnce) {
                        file.__retriedOnce = true;
                        log('Retrying upload (1/2): ' + file.name, 'info');
                        try { uppy.retryUpload(file.id); } catch {}
                    } else if (file && !file.__retriedTwice) {
                        file.__retriedTwice = true;
                        log('Retrying upload (2/2): ' + file.name, 'info');
                        try { uppy.retryUpload(file.id); } catch {}
                    } else {
                        log('Upload error (giving up): ' + (error && error.message ? error.message : error), 'error');
                        showToast('Upload failed after retries', 'error');
                    }
                });
            });

            // Helpers to open pickers from buttons
            window.openFilePicker = function() {
                const el = document.getElementById('filePicker');
                if (el) el.click();
            }
            window.openFolderPicker = function() {
                const el = document.getElementById('folderPicker');
                if (el) el.click();
            }
            // Add a FileList to Uppy, preserving folder paths when available
            window.addFilesToUppy = function(fileList) {
                if (!fileList || !window.uppy) return;
                const existing = window.uppy.getFiles();
                Array.from(fileList).forEach((f) => {
                    const rel = f.webkitRelativePath && f.webkitRelativePath.length ? f.webkitRelativePath : f.name;
                    // De-dup: skip if a file with same name & size already queued
                    if (existing.some(x => x.name === rel && Number(x.size) === Number(f.size))) {
                        log(`Skip duplicate already queued: ${rel}`, 'warn');
                        return;
                    }
                    try {
                        window.uppy.addFile({
                            name: rel,
                            type: f.type || 'application/octet-stream',
                            data: f,
                            meta: { relativePath: rel }
                        });
                        const ub = document.getElementById('uploadBtn');
                        if (ub) ub.disabled = false;
                    } catch (e) {
                        log('Skip file: ' + (e && e.message ? e.message : e), 'error');
                    }
                });
            }

            // Enable Start Upload when a file is added via Uppy dashboard too
            if (window.uppy) {
                window.uppy.on('file-added', () => {
                    const ub = document.getElementById('uploadBtn');
                    if (ub) ub.disabled = false;
                });
            }
            
            log('F3 Transfer ready - Real PacketFS with Native Arithmetic Mode', 'success');

            // Optional: expose a tiny helper to send an IPROG using the arithmetic WS client
            // Usage example (in DevTools):
            //   await window.pfsSendIprog(iprogJson, 'demo-transfer')
            // Overlay helpers
            let __failTimer = null; let __failOnRetry = null; let __failRetryCount = 0;
            function showFailOverlay(message, metrics, opts){
                const o = document.getElementById('failOverlay'); if(!o) return;
                const sub = document.getElementById('failSub'); const cnt = document.getElementById('failCountdown');
                const met = document.getElementById('failMetrics'); const title = document.getElementById('failTitle');
                const retryBtn = document.getElementById('failRetryNow'); const dismissBtn = document.getElementById('failDismiss');
                if (title && message) title.textContent = message;
                if (met) met.textContent = metrics || '';
                let secs = (opts && Number.isFinite(opts.seconds)) ? Math.max(0, Math.floor(opts.seconds)) : 3;
                if (sub) sub.style.display = 'block';
                if (cnt) cnt.textContent = String(secs);
                if (__failTimer) { clearInterval(__failTimer); __failTimer = null; }
                __failOnRetry = (opts && typeof opts.onRetry === 'function') ? opts.onRetry : null;
                const tick = ()=>{
                    secs -= 1; if (cnt) cnt.textContent = String(Math.max(0,secs));
                    if (secs <= 0) { clearInterval(__failTimer); __failTimer = null; if (__failOnRetry) __failOnRetry(); }
                };
                if (secs > 0) __failTimer = setInterval(tick, 1000);
                if (retryBtn) retryBtn.onclick = ()=>{ if(__failTimer) { clearInterval(__failTimer); __failTimer=null; } if(__failOnRetry) __failOnRetry('manual'); };
                if (dismissBtn) dismissBtn.onclick = ()=>{ hideFailOverlay(); };
                o.style.display = 'flex';
            }
            function hideFailOverlay(){ const o = document.getElementById('failOverlay'); if(!o) return; if(__failTimer){clearInterval(__failTimer);} __failTimer=null; __failOnRetry=null; o.style.display='none'; }

            try {
                const mod = await import('/static/pfs-arith/index.js');
                const { PfsArithClient, browserWS } = mod;
                // Default WS channels (aggressive multi-WS on by default)
                const DEFAULT_WS_CHANNELS = Number(localStorage.getItem('PFS_WS_CHANNELS')||'10') || 10;
                window.pfsSendIprogMulti = async function(iprog, transferId, channels){
                    const url = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/pfs-arith';
                    const client = new PfsArithClient(browserWS);
                    const ch = Number(channels||DEFAULT_WS_CHANNELS)||4;
                    const started = performance.now();
                    let res = null;
                    try {
                        if (ch > 1) res = await client.sendIprogMulti(url, iprog, transferId||('tx-'+Date.now()), ch);
                        else res = await client.sendIprog(url, iprog, transferId||('tx-'+Date.now()));
                    } catch (e) {
                        res = { ok: false, bytesSent: 0, elapsedS: (performance.now()-started)/1000 };
                    }
                    const ended = performance.now();
                    try {
                        const elapsedS = (res && Number.isFinite(res.elapsedS)) ? Number(res.elapsedS) : Math.max(0.001, (ended - started)/1000);
                        const bytesSent = (res && typeof res.bytesSent === 'number') ? res.bytesSent : 0;
                        const orig = (iprog && typeof iprog.size === 'number') ? iprog.size : 0;
                        const saved = Math.max(0, orig - bytesSent);
                        const savedPct = orig > 0 ? (saved / orig) * 100 : 0;
                        const speed = bytesSent / Math.max(0.001, elapsedS);
                        if (orig > 0 && bytesSent > 0 && typeof updateAggregates === 'function') {
                            updateAggregates(orig, bytesSent);
                        }
                        const msg = `Arithmetic send${ch>1?` (ch=${ch})`:''}: ${formatFileSize(orig)} â†’ ${formatFileSize(bytesSent)} â€¢ saved ${savedPct.toFixed(1)}% in ${elapsedS.toFixed(2)}s @ ${formatSpeed(speed)}`;
                        log(msg, res && res.ok ? 'success' : 'error');
                        showToast(msg, res && res.ok ? 'success' : 'error');
                        const sp = document.getElementById('transferSpeed');
                        if (sp) sp.textContent = formatSpeed(speed);
                        window.pfsLastResult = res;
                        if (!res || !res.ok) {
                            const metrics = `planned ${formatFileSize(orig)}, sent ${formatFileSize(bytesSent)}, saved ${savedPct.toFixed(1)}%`;
                            const doRetry = async (mode)=>{
                                hideFailOverlay();
                                if (mode !== 'manual') { if (__failRetryCount >= 1) { return; } __failRetryCount++; }
                                log('Retrying arithmetic send (1/1)â€¦','info');
                                try { await window.pfsSendIprogMulti(iprog, transferId, ch); } catch {}
                            };
                            showFailOverlay('TRANSFER FAILED', metrics, { seconds: 3, onRetry: doRetry });
                        } else { __failRetryCount = 0; hideFailOverlay(); }
                    } catch {}
                    return res;
                }
                // Backward-compatible helper
                window.pfsSendIprog = async function(iprog, transferId){ return window.pfsSendIprogMulti(iprog, transferId, DEFAULT_WS_CHANNELS); }
                log('window.pfsSendIprog{,Multi} available (uses /static/pfs-arith; default channels=4)', 'info');
            } catch (e) {
                // Not fatal if library missing
            }
        });

let CURRENT_TENANT_ID = localStorage.getItem('pfs_tenant_id') || 'public';
function setTenantId(tid){
    CURRENT_TENANT_ID = (tid||'public').trim().slice(0,64) || 'public';
    localStorage.setItem('pfs_tenant_id', CURRENT_TENANT_ID);
    const lbl = document.getElementById('tenantIdLabel');
    if (lbl) lbl.textContent = 'tenant: ' + CURRENT_TENANT_ID;
}
// Quick heuristic: allow query param ?tenant=foo for dev override
try {
    const url = new URL(window.location.href);
    const qtid = url.searchParams.get('tenant');
    if (qtid) setTenantId(qtid);
} catch {}

async function pollTenantCompression(){
    try {
        const res = await fetch('/compression/stats', {headers: {'X-Tenant-ID': CURRENT_TENANT_ID}});
        if(!res.ok) throw new Error('http '+res.status);
        const j = await res.json();
        if(j && j.per_tenant){
            const t = j.per_tenant[CURRENT_TENANT_ID];
            if (t){
                const savedPct = (t.saved_percent||0).toFixed(2);
                const savedBytes = formatFileSize(t.saved_bytes||0);
                const orig = formatFileSize(t.total_original||0);
                const tx = formatFileSize(t.total_transmitted||0);
                const banner = document.getElementById('tenantCompressionBanner');
                const statsEl = document.getElementById('tenantCompressionStats');
                if (banner && statsEl){
                    banner.style.display = 'block';
                    statsEl.textContent = `${orig} â†’ ${tx} | saved ${savedBytes} (${savedPct}%) over ${t.uploads||0} upload${(t.uploads||0)===1?'':'s'}`;
                }
            }
        }
    } catch (e) {
        // Silent
    } finally {
        setTimeout(pollTenantCompression, 5000);
    }
}
window.addEventListener('DOMContentLoaded', ()=>{
    pollTenantCompression();
});
    </script>
</body>
</html>