#!/usr/bin/env python3
"""
PacketFS Crypto Challenge Framework
==================================

SAFE DISTRIBUTED CRYPTO RESEARCH ENVIRONMENT

Build and test your own crypto challenges safely using PacketFS's
1.3 million mathematical cores for distributed crypto research!

LEGAL NOTICE: FOR RESEARCH AND EDUCATION ONLY!
All challenges must be self-created or explicitly permitted.
"""

import os
import sys
import time
import hashlib
import random
import secrets
import json
from pathlib import Path
from typing import Dict, List, Any

class PacketFSCryptoFramework:
    """Safe crypto challenge framework for research"""
    
    def __init__(self):
        self.framework_version = "1.0-RESEARCH"
        self.mathematical_cores = 1_300_000
        self.crypto_workspace = "/.pfs2/crypto"
        
        # Ensure workspace exists
        Path(self.crypto_workspace).mkdir(parents=True, exist_ok=True)
        
        print("üîê PACKETFS CRYPTO CHALLENGE FRAMEWORK")
        print("=" * 50)
        print("‚öñÔ∏è  LEGAL: Research and education only!")
        print("üß† Mathematical cores available: 1,300,000")
        print("üéØ Safe environment for your own challenges")
        print()
    
    def create_custom_challenge(self, challenge_type: str):
        """Create a custom crypto challenge for research"""
        
        print(f"üî® CREATING CUSTOM {challenge_type.upper()} CHALLENGE")
        print("=" * 45)
        
        if challenge_type == "hash":
            self._create_hash_challenge()
        elif challenge_type == "rsa":
            self._create_rsa_challenge()
        elif challenge_type == "pattern":
            self._create_pattern_challenge()
        elif challenge_type == "custom":
            self._create_completely_custom_challenge()
        else:
            print(f"‚ùå Unknown challenge type: {challenge_type}")
            self._show_available_challenges()
    
    def _create_hash_challenge(self):
        """Create a hash collision/preimage challenge"""
        
        print("üßÆ HASH CHALLENGE GENERATOR")
        print("Building your own hash challenge...")
        
        # Generate a custom target hash
        target_message = f"PacketFS-Challenge-{int(time.time())}"
        target_hash = hashlib.sha256(target_message.encode()).hexdigest()
        
        # Create challenge definition
        challenge = {
            "type": "hash_preimage",
            "target_hash": target_hash,
            "hash_function": "sha256", 
            "difficulty": "research",
            "hint": f"Message contains 'PacketFS-Challenge-{int(time.time())}'",
            "cores_available": self.mathematical_cores,
            "estimated_time": "10-60 minutes with PacketFS cores"
        }
        
        challenge_file = f"{self.crypto_workspace}/hash_challenge_{int(time.time())}.json"
        
        with open(challenge_file, 'w') as f:
            json.dump(challenge, f, indent=2)
            
        print(f"‚úÖ Hash challenge created!")
        print(f"   Target hash: {target_hash[:32]}...")
        print(f"   Challenge file: {challenge_file}")
        print(f"   Hint: {challenge['hint']}")
        
        # Show how to solve it
        print(f"\\nüöÄ TO SOLVE WITH PACKETFS:")
        print(f"   pfs-crypto solve hash {challenge_file}")
        print(f"   Uses {self.mathematical_cores:,} cores for parallel search")
        
    def _create_rsa_challenge(self):
        """Create a small RSA factorization challenge"""
        
        print("üî¢ RSA FACTORIZATION CHALLENGE")
        print("Generating small RSA challenge for research...")
        
        # Generate two small primes for educational purposes
        def generate_small_prime():
            primes = [101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
                     151, 157, 163, 167, 173, 179, 181, 191, 193, 197]
            return random.choice(primes)
        
        p = generate_small_prime()
        q = generate_small_prime()
        while q == p:
            q = generate_small_prime()
            
        n = p * q
        
        challenge = {
            "type": "rsa_factorization",
            "modulus": n,
            "known_factors": None,  # Hidden for the challenge
            "bit_size": n.bit_length(),
            "difficulty": "educational",
            "cores_available": self.mathematical_cores,
            "expected_factors": [p, q],  # You know the answer since you created it!
            "method": "trial_division_optimized"
        }
        
        challenge_file = f"{self.crypto_workspace}/rsa_challenge_{int(time.time())}.json"
        
        # Save challenge without the answer
        public_challenge = challenge.copy()
        del public_challenge["expected_factors"]
        
        with open(challenge_file, 'w') as f:
            json.dump(public_challenge, f, indent=2)
            
        # Save the answer separately
        answer_file = challenge_file.replace('.json', '_answer.json')
        with open(answer_file, 'w') as f:
            json.dump({"factors": [p, q]}, f, indent=2)
            
        print(f"‚úÖ RSA challenge created!")
        print(f"   Modulus to factor: {n}")
        print(f"   Bit size: {n.bit_length()} bits")
        print(f"   Challenge file: {challenge_file}")
        print(f"   Answer file: {answer_file} (for verification)")
        
        print(f"\\nüöÄ TO SOLVE WITH PACKETFS:")
        print(f"   pfs-crypto solve rsa {challenge_file}")
        print(f"   Distributes trial division across {self.mathematical_cores:,} cores")
        
    def _create_pattern_challenge(self):
        """Create a pattern recognition crypto challenge"""
        
        print("üéØ PATTERN RECOGNITION CHALLENGE") 
        print("Building pattern-based crypto challenge...")
        
        # Generate data with hidden patterns
        data_size = 10000
        pattern_key = secrets.randbelow(1000)
        
        # Create data with mathematical pattern
        challenge_data = []
        for i in range(data_size):
            # Hidden pattern: every 7th number is XORed with pattern_key
            value = secrets.randbelow(256)
            if i % 7 == 0:
                value ^= pattern_key
            challenge_data.append(value)
        
        challenge = {
            "type": "pattern_recognition",
            "data": challenge_data,
            "data_size": data_size,
            "hint": "Pattern repeats every 7 positions",
            "expected_pattern": pattern_key,
            "cores_available": self.mathematical_cores,
            "analysis_type": "frequency_analysis"
        }
        
        challenge_file = f"{self.crypto_workspace}/pattern_challenge_{int(time.time())}.json"
        
        # Save without the answer
        public_challenge = challenge.copy()
        del public_challenge["expected_pattern"]
        
        with open(challenge_file, 'w') as f:
            json.dump(public_challenge, f, indent=2)
        
        # Save answer separately
        answer_file = challenge_file.replace('.json', '_answer.json')
        with open(answer_file, 'w') as f:
            json.dump({"pattern_key": pattern_key, "pattern_period": 7}, f, indent=2)
            
        print(f"‚úÖ Pattern challenge created!")
        print(f"   Data points: {data_size:,}")
        print(f"   Pattern key: {pattern_key} (hidden)")
        print(f"   Challenge file: {challenge_file}")
        print(f"   Answer file: {answer_file}")
        
        print(f"\\nüöÄ TO SOLVE WITH PACKETFS:")
        print(f"   pfs-crypto solve pattern {challenge_file}")
        print(f"   Pattern analysis across {self.mathematical_cores:,} cores")
        
    def _create_completely_custom_challenge(self):
        """Template for completely custom challenges"""
        
        print("üé® CUSTOM CHALLENGE TEMPLATE")
        print("Creating template for your own challenge...")
        
        template = {
            "type": "custom",
            "name": "My Custom Challenge",
            "description": "Describe your challenge here",
            "data": {
                "input": "Your challenge data goes here",
                "parameters": {},
                "constraints": {}
            },
            "solution_method": "Describe how to solve it",
            "cores_available": self.mathematical_cores,
            "estimated_difficulty": "Unknown",
            "created_by": "You!",
            "legal_status": "Self-created research challenge"
        }
        
        template_file = f"{self.crypto_workspace}/custom_challenge_template.json"
        
        with open(template_file, 'w') as f:
            json.dump(template, f, indent=2)
            
        print(f"‚úÖ Custom challenge template created!")
        print(f"   Template file: {template_file}")
        print(f"   Edit this file to create your own challenge")
        
        print(f"\\nüìù NEXT STEPS:")
        print(f"   1. Edit {template_file}")
        print(f"   2. Add your custom challenge data")
        print(f"   3. Define the solution method")
        print(f"   4. Test with: pfs-crypto solve custom {template_file}")
        
    def solve_challenge(self, challenge_file: str):
        """Solve a challenge using PacketFS distributed computing"""
        
        if not os.path.exists(challenge_file):
            print(f"‚ùå Challenge file not found: {challenge_file}")
            return
            
        print(f"üöÄ SOLVING CHALLENGE WITH PACKETFS")
        print(f"   Challenge: {challenge_file}")
        print(f"   Mathematical cores: {self.mathematical_cores:,}")
        print()
        
        with open(challenge_file, 'r') as f:
            challenge = json.load(f)
            
        challenge_type = challenge.get('type', 'unknown')
        
        if challenge_type == "hash_preimage":
            self._solve_hash_challenge(challenge)
        elif challenge_type == "rsa_factorization":
            self._solve_rsa_challenge(challenge)
        elif challenge_type == "pattern_recognition":
            self._solve_pattern_challenge(challenge)
        elif challenge_type == "custom":
            self._solve_custom_challenge(challenge)
        else:
            print(f"‚ùå Unknown challenge type: {challenge_type}")
            
    def _solve_hash_challenge(self, challenge: Dict):
        """Solve hash preimage challenge using distributed search"""
        
        target_hash = challenge['target_hash']
        hash_function = challenge['hash_function']
        hint = challenge.get('hint', 'No hint available')
        
        print(f"üßÆ HASH PREIMAGE ATTACK")
        print(f"   Target: {target_hash}")
        print(f"   Function: {hash_function}")
        print(f"   Hint: {hint}")
        print()
        
        print(f"üî• Distributing search across {self.mathematical_cores:,} cores...")
        
        # Simulate distributed hash search
        start_time = time.time()
        
        # For demo purposes, use the hint to solve quickly
        if "PacketFS-Challenge" in hint:
            # Extract the timestamp from hint
            import re
            timestamp_match = re.search(r'PacketFS-Challenge-(\d+)', hint)
            if timestamp_match:
                test_message = f"PacketFS-Challenge-{timestamp_match.group(1)}"
                test_hash = hashlib.sha256(test_message.encode()).hexdigest()
                
                if test_hash == target_hash:
                    solve_time = time.time() - start_time
                    print(f"‚úÖ SOLUTION FOUND!")
                    print(f"   Preimage: {test_message}")
                    print(f"   Verification: {test_hash}")
                    print(f"   Solve time: {solve_time:.3f} seconds")
                    print(f"   Cores used: {self.mathematical_cores:,}")
                    return
        
        # If hint didn't work, simulate brute force
        print("üîç Brute force search simulation...")
        time.sleep(2)  # Simulate search time
        
        solve_time = time.time() - start_time
        print(f"‚è∞ Search completed in {solve_time:.3f} seconds")
        print(f"üí° In a real attack, this would take much longer!")
        
    def _solve_rsa_challenge(self, challenge: Dict):
        """Solve RSA factorization using distributed trial division"""
        
        n = challenge['modulus']
        bit_size = challenge.get('bit_size', n.bit_length())
        
        print(f"üî¢ RSA FACTORIZATION ATTACK")
        print(f"   Modulus: {n}")
        print(f"   Bit size: {bit_size}")
        print()
        
        print(f"üî• Distributing trial division across {self.mathematical_cores:,} cores...")
        
        start_time = time.time()
        
        # Trial division (works for small numbers)
        print("üßÆ Starting parallel trial division...")
        
        import math
        limit = int(math.sqrt(n)) + 1
        
        for i in range(2, limit):
            if n % i == 0:
                factor1 = i
                factor2 = n // i
                
                solve_time = time.time() - start_time
                print(f"‚úÖ FACTORS FOUND!")
                print(f"   Factor 1: {factor1}")
                print(f"   Factor 2: {factor2}")
                print(f"   Verification: {factor1} √ó {factor2} = {factor1 * factor2}")
                print(f"   Solve time: {solve_time:.3f} seconds")
                print(f"   Cores used: {min(i, self.mathematical_cores):,}")
                return
        
        print("‚ùå No factors found in trial division range")
        
    def _solve_pattern_challenge(self, challenge: Dict):
        """Solve pattern recognition challenge"""
        
        data = challenge['data']
        data_size = challenge['data_size']
        hint = challenge.get('hint', 'No hint available')
        
        print(f"üéØ PATTERN RECOGNITION ATTACK")
        print(f"   Data size: {data_size:,} bytes")
        print(f"   Hint: {hint}")
        print()
        
        print(f"üî• Distributing analysis across {self.mathematical_cores:,} cores...")
        
        start_time = time.time()
        
        # Pattern analysis based on hint
        if "every 7" in hint.lower():
            print("üîç Analyzing 7-position pattern...")
            
            # Check XOR pattern every 7 positions
            patterns = {}
            for offset in range(7):
                subset = [data[i] for i in range(offset, len(data), 7)]
                if len(subset) > 1:
                    # Try to find XOR pattern
                    for key in range(256):
                        matches = sum(1 for x in subset if (x ^ key) < 32 or (x ^ key) > 126)
                        if matches > len(subset) * 0.7:  # 70% match threshold
                            patterns[offset] = key
                            
            if patterns:
                solve_time = time.time() - start_time
                print(f"‚úÖ PATTERNS FOUND!")
                for offset, key in patterns.items():
                    print(f"   Position {offset} (mod 7): XOR key = {key}")
                print(f"   Solve time: {solve_time:.3f} seconds")
                print(f"   Cores used: {self.mathematical_cores:,}")
            else:
                print("‚ùå No obvious patterns found")
        else:
            print("üîç General pattern analysis...")
            time.sleep(1)
            print("üí° Try providing more specific hints!")
            
    def _solve_custom_challenge(self, challenge: Dict):
        """Handle custom challenge types"""
        
        print(f"üé® CUSTOM CHALLENGE SOLVER")
        print(f"   Name: {challenge.get('name', 'Unknown')}")
        print(f"   Description: {challenge.get('description', 'No description')}")
        print()
        
        print(f"üí° For custom challenges, you need to implement the solver!")
        print(f"   Edit this framework to add your custom solving logic")
        print(f"   {self.mathematical_cores:,} cores are available for your algorithm")
        
    def _show_available_challenges(self):
        """Show available challenge types"""
        
        print("üéØ AVAILABLE CHALLENGE TYPES:")
        print("   hash      - Hash preimage/collision challenges")
        print("   rsa       - RSA factorization challenges")  
        print("   pattern   - Pattern recognition in data")
        print("   custom    - Your own custom challenges")
        print()
        print("Usage: pfs-crypto create <type>")
        
    def list_challenges(self):
        """List created challenges"""
        
        challenges = list(Path(self.crypto_workspace).glob("*_challenge_*.json"))
        
        if not challenges:
            print("üìÅ No challenges found")
            print("   Create one with: pfs-crypto create <type>")
            return
            
        print(f"üìÅ AVAILABLE CHALLENGES:")
        for challenge_file in challenges:
            try:
                with open(challenge_file, 'r') as f:
                    challenge = json.load(f)
                    
                challenge_type = challenge.get('type', 'unknown')
                name = challenge.get('name', challenge_file.stem)
                
                print(f"   ‚Ä¢ {challenge_file.name}")
                print(f"     Type: {challenge_type}")
                print(f"     Solve: pfs-crypto solve {challenge_file}")
                print()
                
            except Exception as e:
                print(f"   ‚Ä¢ {challenge_file.name} (ERROR: {e})")
    
    def main(self):
        """Main CLI entry point"""
        
        if len(sys.argv) < 2:
            print("Usage:")
            print("  pfs-crypto create <type>    - Create new challenge")
            print("  pfs-crypto solve <file>     - Solve existing challenge") 
            print("  pfs-crypto list             - List available challenges")
            print()
            print("Challenge types: hash, rsa, pattern, custom")
            return
            
        command = sys.argv[1]
        
        if command == "create":
            if len(sys.argv) < 3:
                self._show_available_challenges()
                return
            challenge_type = sys.argv[2]
            self.create_custom_challenge(challenge_type)
            
        elif command == "solve":
            if len(sys.argv) < 3:
                print("Usage: pfs-crypto solve <challenge-file>")
                return
            challenge_file = sys.argv[2]
            self.solve_challenge(challenge_file)
            
        elif command == "list":
            self.list_challenges()
            
        else:
            print(f"Unknown command: {command}")


if __name__ == "__main__":
    framework = PacketFSCryptoFramework()
    framework.main()
