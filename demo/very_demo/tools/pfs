#!/usr/bin/env python3
"""
PacketFS CLI Tool - rsync-like syntax with telnet protocol
Usage: pfs [source] [destination] [options]

Examples:
  pfs file.txt user@host:/remote/path/          # Upload file
  pfs user@host:/remote/file.txt ./local/      # Download file  
  pfs -r /local/dir/ user@host:/remote/dir/    # Sync directory
  pfs --shell user@host                        # Interactive shell
  pfs --server --port 8337                     # Start server
  pfs --benchmark 1GB user@host               # Performance test
"""

import os
import sys
import argparse
import socket
import struct
import json
import hashlib
import time
import threading
import getpass
import readline
import glob
from pathlib import Path
from typing import Dict, List, Optional, Tuple, TYPE_CHECKING
from dataclasses import dataclass

if TYPE_CHECKING:
    import socket as socket_module

# Add PacketFS modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
from packetfs.protocol import ProtocolEncoder, ProtocolDecoder, SyncConfig

# Import existing file transfer system
from packetfs_file_transfer import PacketFSFileTransfer, PFS_PORT, PFS_MAGIC

# Enhanced Protocol Constants
CMD_SHELL = 10
CMD_LS = 11
CMD_CD = 12
CMD_MKDIR = 13
CMD_RM = 14
CMD_STAT = 15
CMD_BENCHMARK = 16
CMD_QUIT = 17
CMD_PWD = 18
CMD_RSYNC = 19
CMD_PROGRESS = 20

@dataclass
class PFSConnection:
    """Represents a PacketFS connection"""
    host: str
    port: int = PFS_PORT
    user: Optional[str] = None
    password: Optional[str] = None
    socket: Optional['socket.socket'] = None
    authenticated: bool = False
    current_dir: str = "/"

class PacketFSShell:
    """Interactive PacketFS shell (like SSH)"""
    
    def __init__(self, conn: PFSConnection):
        self.conn = conn
        self.pfs = PacketFSFileTransfer()
        self.running = False
        self.commands = {
            'ls': self.cmd_ls,
            'cd': self.cmd_cd,
            'pwd': self.cmd_pwd,
            'mkdir': self.cmd_mkdir,
            'rm': self.cmd_rm,
            'stat': self.cmd_stat,
            'get': self.cmd_get,
            'put': self.cmd_put,
            'sync': self.cmd_sync,
            'benchmark': self.cmd_benchmark,
            'help': self.cmd_help,
            'exit': self.cmd_exit,
            'quit': self.cmd_exit,
        }
    
    def connect(self) -> bool:
        """Connect to PacketFS server"""
        try:
            print(f"üîó Connecting to {self.conn.user}@{self.conn.host}:{self.conn.port}")
            self.conn.socket = self.pfs.connect_client(self.conn.host, self.conn.port)
            
            # Authenticate if needed
            if self.conn.user:
                if not self.conn.password:
                    self.conn.password = getpass.getpass(f"Password for {self.conn.user}: ")
                
                auth_data = {
                    'username': self.conn.user,
                    'password': self.conn.password
                }
                self.pfs.send_message(self.conn.socket, CMD_SHELL, json.dumps(auth_data).encode())
                msg_type, response = self.pfs.receive_message(self.conn.socket)
                
                if msg_type == CMD_SHELL:
                    result = json.loads(response.decode())
                    if result.get('authenticated'):
                        self.conn.authenticated = True
                        self.conn.current_dir = result.get('home_dir', '/')
                        print(f"‚úÖ Connected as {self.conn.user}")
                        return True
                    else:
                        print("‚ùå Authentication failed")
                        return False
            
            self.conn.authenticated = True
            print("‚úÖ Connected (no authentication required)")
            return True
            
        except Exception as e:
            print(f"‚ùå Connection failed: {e}")
            return False
    
    def run(self):
        """Run interactive shell"""
        if not self.connect():
            return
        
        self.running = True
        print(f"\nPacketFS Shell - Connected to {self.conn.host}")
        print("Type 'help' for available commands, 'exit' to quit\n")
        
        # Set up readline for command history
        readline.parse_and_bind('tab: complete')
        readline.set_completer(self.complete_command)
        
        while self.running:
            try:
                prompt = f"pfs:{self.conn.current_dir}$ "
                command = input(prompt).strip()
                
                if not command:
                    continue
                
                self.execute_command(command)
                
            except KeyboardInterrupt:
                print("\n^C")
                continue
            except EOFError:
                print("\nBye!")
                break
        
        if self.conn.socket:
            self.conn.socket.close()
    
    def execute_command(self, command: str):
        """Execute shell command"""
        parts = command.split()
        if not parts:
            return
        
        cmd = parts[0]
        args = parts[1:]
        
        if cmd in self.commands:
            try:
                self.commands[cmd](args)
            except Exception as e:
                print(f"‚ùå Error: {e}")
        else:
            print(f"‚ùå Unknown command: {cmd}. Type 'help' for available commands.")
    
    def complete_command(self, text: str, state: int):
        """Tab completion for commands"""
        options = [cmd for cmd in self.commands.keys() if cmd.startswith(text)]
        if state < len(options):
            return options[state]
        return None
    
    def cmd_ls(self, args: List[str]):
        """List directory contents"""
        path = args[0] if args else self.conn.current_dir
        
        request = {'command': 'ls', 'path': path}
        self.pfs.send_message(self.conn.socket, CMD_LS, json.dumps(request).encode())
        
        msg_type, response = self.pfs.receive_message(self.conn.socket)
        if msg_type == CMD_LS:
            result = json.loads(response.decode())
            if result.get('success'):
                files = result.get('files', [])
                for file_info in files:
                    permissions = file_info.get('permissions', '----------')
                    size = file_info.get('size', 0)
                    name = file_info.get('name', '')
                    modified = file_info.get('modified', '')
                    print(f"{permissions} {size:>10} {modified} {name}")
            else:
                print(f"‚ùå {result.get('error', 'Failed to list directory')}")
    
    def cmd_cd(self, args: List[str]):
        """Change directory"""
        if not args:
            print("Usage: cd <directory>")
            return
        
        new_path = args[0]
        request = {'command': 'cd', 'path': new_path}
        self.pfs.send_message(self.conn.socket, CMD_CD, json.dumps(request).encode())
        
        msg_type, response = self.pfs.receive_message(self.conn.socket)
        if msg_type == CMD_CD:
            result = json.loads(response.decode())
            if result.get('success'):
                self.conn.current_dir = result.get('new_path', new_path)
            else:
                print(f"‚ùå {result.get('error', 'Failed to change directory')}")
    
    def cmd_pwd(self, args: List[str]):
        """Print working directory"""
        print(self.conn.current_dir)
    
    def cmd_mkdir(self, args: List[str]):
        """Create directory"""
        if not args:
            print("Usage: mkdir <directory>")
            return
        
        for dir_name in args:
            request = {'command': 'mkdir', 'path': dir_name}
            self.pfs.send_message(self.conn.socket, CMD_MKDIR, json.dumps(request).encode())
            
            msg_type, response = self.pfs.receive_message(self.conn.socket)
            if msg_type == CMD_MKDIR:
                result = json.loads(response.decode())
                if result.get('success'):
                    print(f"‚úÖ Created directory: {dir_name}")
                else:
                    print(f"‚ùå Failed to create {dir_name}: {result.get('error', 'Unknown error')}")
    
    def cmd_rm(self, args: List[str]):
        """Remove files/directories"""
        if not args:
            print("Usage: rm <file1> [file2] ...")
            return
        
        for file_name in args:
            request = {'command': 'rm', 'path': file_name}
            self.pfs.send_message(self.conn.socket, CMD_RM, json.dumps(request).encode())
            
            msg_type, response = self.pfs.receive_message(self.conn.socket)
            if msg_type == CMD_RM:
                result = json.loads(response.decode())
                if result.get('success'):
                    print(f"‚úÖ Removed: {file_name}")
                else:
                    print(f"‚ùå Failed to remove {file_name}: {result.get('error', 'Unknown error')}")
    
    def cmd_stat(self, args: List[str]):
        """Show file/directory statistics"""
        if not args:
            print("Usage: stat <file>")
            return
        
        file_path = args[0]
        request = {'command': 'stat', 'path': file_path}
        self.pfs.send_message(self.conn.socket, CMD_STAT, json.dumps(request).encode())
        
        msg_type, response = self.pfs.receive_message(self.conn.socket)
        if msg_type == CMD_STAT:
            result = json.loads(response.decode())
            if result.get('success'):
                info = result.get('info', {})
                print(f"File: {info.get('name', file_path)}")
                print(f"Size: {info.get('size', 0)} bytes")
                print(f"Type: {info.get('type', 'unknown')}")
                print(f"Permissions: {info.get('permissions', 'unknown')}")
                print(f"Modified: {info.get('modified', 'unknown')}")
                print(f"Checksum: {info.get('checksum', 'unknown')}")
            else:
                print(f"‚ùå {result.get('error', 'Failed to get file info')}")
    
    def cmd_get(self, args: List[str]):
        """Download file from remote"""
        if len(args) < 1:
            print("Usage: get <remote_file> [local_file]")
            return
        
        remote_file = args[0]
        local_file = args[1] if len(args) > 1 else os.path.basename(remote_file)
        
        print(f"üì• Downloading {remote_file} -> {local_file}")
        success = self.pfs.request_file(self.conn.host, remote_file, local_file)
        
        if success:
            print(f"‚úÖ Download completed: {local_file}")
        else:
            print("‚ùå Download failed")
    
    def cmd_put(self, args: List[str]):
        """Upload file to remote"""
        if len(args) < 1:
            print("Usage: put <local_file> [remote_file]")
            return
        
        local_file = args[0]
        remote_file = args[1] if len(args) > 1 else os.path.basename(local_file)
        
        if not os.path.exists(local_file):
            print(f"‚ùå Local file not found: {local_file}")
            return
        
        print(f"üì§ Uploading {local_file} -> {remote_file}")
        # This would need server-side upload support
        print("‚ö†Ô∏è  Upload functionality requires server enhancement")
    
    def cmd_sync(self, args: List[str]):
        """Sync directories (rsync-like)"""
        if len(args) < 2:
            print("Usage: sync <source> <destination>")
            print("Examples:")
            print("  sync ./local/ /remote/path/    # Upload directory")
            print("  sync /remote/path/ ./local/    # Download directory")
            return
        
        source, dest = args[0], args[1]
        print(f"üîÑ Syncing {source} -> {dest}")
        print("‚ö†Ô∏è  Directory sync requires enhancement")
    
    def cmd_benchmark(self, args: List[str]):
        """Run performance benchmark"""
        size = args[0] if args else "10MB"
        print(f"‚ö° Running benchmark with {size} transfer...")
        
        request = {'command': 'benchmark', 'size': size}
        self.pfs.send_message(self.conn.socket, CMD_BENCHMARK, json.dumps(request).encode())
        
        msg_type, response = self.pfs.receive_message(self.conn.socket)
        if msg_type == CMD_BENCHMARK:
            result = json.loads(response.decode())
            if result.get('success'):
                print(f"üìä Benchmark Results:")
                print(f"   Size: {result.get('size', 'unknown')}")
                print(f"   Time: {result.get('duration', 0):.3f}s")
                print(f"   Throughput: {result.get('throughput', 0):.2f} MB/s")
                print(f"   PacketFS speedup: {result.get('speedup', 1):.1f}x")
            else:
                print(f"‚ùå Benchmark failed: {result.get('error', 'Unknown error')}")
    
    def cmd_help(self, args: List[str]):
        """Show help"""
        print("PacketFS Shell Commands:")
        print("========================")
        print("  ls [path]               - List directory contents")
        print("  cd <path>               - Change directory")
        print("  pwd                     - Print working directory")
        print("  mkdir <dir> [dir2...]   - Create directories")
        print("  rm <file> [file2...]    - Remove files/directories")
        print("  stat <file>             - Show file information")
        print("  get <remote> [local]    - Download file")
        print("  put <local> [remote]    - Upload file (coming soon)")
        print("  sync <src> <dst>        - Sync directories (coming soon)")
        print("  benchmark [size]        - Run performance test")
        print("  help                    - Show this help")
        print("  exit, quit              - Exit shell")
    
    def cmd_exit(self, args: List[str]):
        """Exit shell"""
        self.running = False
        print("Goodbye! üëã")

class PacketFSCLI:
    """Main PacketFS CLI tool"""
    
    def __init__(self):
        self.pfs = PacketFSFileTransfer()
    
    def parse_connection_string(self, conn_str: str) -> PFSConnection:
        """Parse rsync-like connection string: [user@]host[:port][:/path]"""
        user = None
        host = conn_str
        port = PFS_PORT
        path = "/"
        
        # Extract user
        if '@' in conn_str:
            user, rest = conn_str.split('@', 1)
            conn_str = rest
        
        # Extract port and path
        if ':' in conn_str:
            parts = conn_str.split(':')
            host = parts[0]
            
            if len(parts) > 1:
                # Check if second part is port or path
                second_part = parts[1]
                if second_part.startswith('/'):
                    path = second_part
                elif second_part.isdigit():
                    port = int(second_part)
                    if len(parts) > 2:
                        path = parts[2]
        
        return PFSConnection(host=host, port=port, user=user, current_dir=path)
    
    def rsync_transfer(self, source: str, dest: str, recursive: bool = False, 
                      verbose: bool = False, dry_run: bool = False) -> bool:
        """rsync-like file transfer"""
        print(f"üîÑ {'DRY RUN: ' if dry_run else ''}PacketFS transfer: {source} -> {dest}")
        
        # Parse source and destination
        if ':' in source and '@' in source:
            # Remote source -> local dest
            conn = self.parse_connection_string(source.split(':')[0])
            remote_path = source.split(':', 1)[1]
            local_path = dest
            direction = "download"
        elif ':' in dest and '@' in dest:
            # Local source -> remote dest  
            conn = self.parse_connection_string(dest.split(':')[0])
            local_path = source
            remote_path = dest.split(':', 1)[1]
            direction = "upload"
        else:
            print("‚ùå Invalid syntax. Use user@host:/path format")
            return False
        
        if dry_run:
            print(f"Would {direction}: {local_path} ‚Üî {remote_path}")
            print(f"Connection: {conn.user}@{conn.host}:{conn.port}")
            return True
        
        try:
            if direction == "download":
                print(f"üì• Downloading from {conn.host}")
                return self.pfs.request_file(conn.host, remote_path, local_path)
            else:
                print("üì§ Upload functionality coming soon!")
                return False
                
        except Exception as e:
            print(f"‚ùå Transfer failed: {e}")
            return False
    
    def start_server(self, host: str = "0.0.0.0", port: int = PFS_PORT):
        """Start PacketFS server"""
        print(f"üöÄ Starting PacketFS server on {host}:{port}")
        print("Enhanced with shell, rsync, and telnet support!")
        
        server_pfs = PacketFSFileTransfer(host, port)
        try:
            server_pfs.start_server()
        except KeyboardInterrupt:
            print("\nüõë Server stopping...")
            server_pfs.stop()
            server_pfs.print_stats()
    
    def interactive_shell(self, connection_string: str):
        """Start interactive shell"""
        conn = self.parse_connection_string(connection_string)
        shell = PacketFSShell(conn)
        shell.run()
    
    def benchmark(self, connection_string: str, size: str = "100MB"):
        """Run performance benchmark"""
        conn = self.parse_connection_string(connection_string)
        
        print(f"‚ö° PacketFS Benchmark: {size} transfer to {conn.host}")
        print("=" * 60)
        
        # Create test file
        size_bytes = self.parse_size(size)
        test_file = f"/tmp/pfs_benchmark_{size}.bin"
        
        print(f"üìÅ Creating {size} test file...")
        with open(test_file, 'wb') as f:
            chunk_size = 1024 * 1024  # 1MB chunks
            remaining = size_bytes
            while remaining > 0:
                chunk = min(chunk_size, remaining)
                f.write(os.urandom(chunk))
                remaining -= chunk
        
        # Test transfer
        start_time = time.time()
        success = self.pfs.request_file(conn.host, test_file, f"/tmp/benchmark_received_{size}.bin")
        duration = time.time() - start_time
        
        if success:
            throughput = (size_bytes / 1024 / 1024) / duration
            print(f"\nüìä Benchmark Results:")
            print(f"   File size: {size}")
            print(f"   Duration: {duration:.3f} seconds")
            print(f"   Throughput: {throughput:.2f} MB/s")
            print(f"   Status: ‚úÖ SUCCESS")
        else:
            print("‚ùå Benchmark failed")
        
        # Cleanup
        try:
            os.remove(test_file)
        except:
            pass
    
    def parse_size(self, size_str: str) -> int:
        """Parse size string like '100MB', '1GB', etc."""
        size_str = size_str.upper()
        multipliers = {
            'B': 1,
            'KB': 1024,
            'MB': 1024**2,
            'GB': 1024**3,
            'TB': 1024**4
        }
        
        for suffix, mult in multipliers.items():
            if size_str.endswith(suffix):
                num_str = size_str[:-len(suffix)]
                return int(float(num_str) * mult)
        
        # Default to bytes
        return int(size_str)

def main():
    parser = argparse.ArgumentParser(
        description="PacketFS CLI - rsync-like file transfer with telnet protocol",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  pfs file.txt user@host:/path/file.txt        # Upload file
  pfs user@host:/file.txt ./local.txt          # Download file
  pfs -r /local/dir/ user@host:/remote/dir/    # Sync directory
  pfs --shell user@host                        # Interactive shell
  pfs --server --port 8337                     # Start server
  pfs --benchmark 1GB user@host               # Performance test

Connection formats:
  host                    # Plain host, default port
  host:port               # Host with custom port
  user@host               # With username (will prompt for password)
  user@host:port:/path    # Full specification
        """
    )
    
    parser.add_argument('source', nargs='?', help='Source file/directory or connection string')
    parser.add_argument('dest', nargs='?', help='Destination file/directory')
    
    # Transfer options
    parser.add_argument('-r', '--recursive', action='store_true', help='Recursive directory sync')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-n', '--dry-run', action='store_true', help='Show what would be done')
    parser.add_argument('--progress', action='store_true', help='Show progress during transfer')
    
    # Mode options
    parser.add_argument('--shell', action='store_true', help='Start interactive shell')
    parser.add_argument('--server', action='store_true', help='Start PacketFS server')
    parser.add_argument('--benchmark', help='Run benchmark with specified size (e.g., 100MB)')
    
    # Server options
    parser.add_argument('--host', default='0.0.0.0', help='Server bind address')
    parser.add_argument('--port', type=int, default=PFS_PORT, help='Server port')
    
    args = parser.parse_args()
    
    cli = PacketFSCLI()
    
    # Server mode
    if args.server:
        cli.start_server(args.host, args.port)
        return
    
    # Shell mode
    if args.shell:
        if not args.source:
            print("‚ùå Shell mode requires connection string")
            print("Example: pfs --shell user@host")
            sys.exit(1)
        cli.interactive_shell(args.source)
        return
    
    # Benchmark mode
    if args.benchmark:
        if not args.source:
            print("‚ùå Benchmark mode requires connection string")
            print("Example: pfs --benchmark 100MB user@host")
            sys.exit(1)
        cli.benchmark(args.source, args.benchmark)
        return
    
    # Transfer mode
    if not args.source or not args.dest:
        parser.print_help()
        sys.exit(1)
    
    success = cli.rsync_transfer(args.source, args.dest, args.recursive, args.verbose, args.dry_run)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
